<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DETION ARENA: LEAGUE OF DUNGEONEERS</title>
    <style>
        /* ESTILOS GENERALES - MEJORADOS */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        }
        
        body { 
            background-color: #1a1a1a; 
            color: white; 
            overflow-x: hidden;
            min-height: 100vh;
            background: url('assets/imagenes/fondo.png') no-repeat center center fixed;
            background-size: cover;
            position: relative;
            
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.0);
            z-index: -1;
        }
        
        /* CONTENEDOR PRINCIPAL - REORGANIZADO */
        #app-container { 
            position: relative; 
            width: 100%; 
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(30, 30, 30, 0.2); /* Fondo ligeramente más claro con transparencia */
        }
        
        /* HEADER CON TÍTULO */
        .header-container {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }
        
        .titulo-container {
            width: 90%;
            max-width: 800px;
            height: 150px;
            margin: 0 auto;
            background-size: contain;
        }
        
        /* PANEL SUPERIOR (CONTROLES) */
        #top-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(60, 60, 60, 0.7);
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #5D4037;
            justify-content: space-around;
            align-items: center;
        }
        
        /* CONTENEDORES DE NIVEL Y APUESTA - MEJORADOS */
        .config-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 150px;
        }
        
        .config-label {
            background-color: transparent;
            color: #d4af37;
            font-weight: bold;
            text-align: center;
            font-size: 1.8rem;
            margin: 10px 0;
            text-shadow: 1px 1px 2px #000;
            min-width: 50px;
        }
        
        .config-title {
            color: #d4af37;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 1px #000;
        }
        
        .config-panel { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 10px; 
        }
        
        /* Selector de Arena */
        .select-arena {
            background: rgba(40, 40, 40, 0.9);
            color: #fff;
            border: 2px solid #5D4037;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 1rem;
            width: 100%;
            margin-top: 5px;
        }
        
        /* BOTONES - MEJORADOS */
        .btn { 
            width: 60px;
            height: 60px;
            background-color: #3a3a3a; 
            border: none; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            background-size: 70%; 
            background-repeat: no-repeat; 
            background-position: center; 
            transition: all 0.3s;
            border-radius: 6px;
            border: 2px solid #5D4037;
        }
        
        .btn:hover { 
            transform: translateY(-2px);
            filter: brightness(1.2);
            border-color: #d4af37;
        }
        
        .btn:disabled { 
            background-color: #555555; 
            cursor: not-allowed; 
            opacity: 0.6;
        }
        
        /* CONTENEDOR DEL LOG - MEJORADO */
        #log-container { 
            position: relative;
            width: 100%;
            height: 200px; /* Altura fija */
            margin: 0 auto 20px;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background: url('assets/imagenes/pergamino.png') no-repeat center center; 
            background-size: cover; 
            padding: 10px;
            overflow: hidden; /* Ocultar desbordamiento */
        }
        
        #event-log { 
            width: 100%;
            height: 100%;
            background-color: transparent; 
            color: #3a2c0e; 
            border: none; 
            text-align: center; 
            overflow: auto; /* Habilitar scroll */
            padding: 15px;
            font-size: 1rem;
            line-height: 1.4;
            font-weight: 300;
        }
        
        /* CONTENEDOR DE LA CUADRICULA - MOVIDO ABAJO */
        #grid-section {
            width: 100%;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: rgba(60, 60, 60, 0.7);
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #5D4037;
        }
        
        .grid-title {
            color: #d4af37;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px #000;
        }
        
        #grid-container { 
            position: relative;
            cursor: move; 
            user-select: none; 
            /* Tamaño inicial, será actualizado por JS */
            width: 90vmin;
            height: 67.5vmin;
            background-size: contain; /* Cambiado a contain para mantener proporción */
            border: 3px solid #8B4513; 
            border-radius: 5px; 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7); 
            z-index: 10; 
            margin-bottom: 20px;
            overflow: hidden;
            opacity: 0; /* Inicialmente oculto */
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        #grid-container.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /* CONTENIDO DE LA CUADRICULA - MEJORADO Y VISIBLE */
        #grid-content { 
            position: relative; 
            width: 100%; 
            height: 100%; 
            display: grid; 
            gap: 4px; 
            padding: 1.5vmin; 
            z-index: 2;
        }

        /* CELDAS DE LA CUADRICULA - MEJORADO Y VISIBLE */
        .grid-cell { 
            background-color: rgba(160, 120, 80, 0.7); 
            border: 2px solid rgba(100, 70, 40, 0.9); 
            border-radius: 4px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            position: relative; 
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        
        .grid-cell.invalida {
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px dashed rgba(255, 255, 255, 0.2);
        }
        
        /* BOTONES PRINCIPALES - MEJORADOS */
        #main-buttons { 
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            z-index: 10; 
            width: 100%;
            padding: 15px;
            background-color: rgba(45, 45, 45, 0.8);
            border-radius: 12px;
            border: 2px solid #8B4513;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .main-btn {
            width: 80px;
            height: 80px;
        }
        
        /* NIVEL ARENA - MEJORADO */
        #nivel-arena-container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            z-index: 4; 
            width: auto; 
            margin: 15px 0;
        }
        
        #nivel-arena-label { 
            background-color: rgba(139, 69, 19, 0.8); 
            color: gold; 
            font-weight: bold; 
            padding: 10px 20px; 
            border-radius: 5px; 
            text-align: center; 
            font-size: 1.2rem; 
            border: 2px solid #8B4513; 
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.7); 
        }
        
        /* ESTILOS DE TEXTO PARA LOGS */
        .log-titulo { 
            color: #8B4513; 
            font-weight: bold; 
            font-size: 1.2em;
        }
        
        .log-recompensa { 
            color: #006400; 
        }
        
        .log-enemigo { 
            color: #8B0000; 
            font-weight: bold; 
        }
        
        .log-lista { 
            color: #3a2c0e; 
        }
        
        .log-ronda { 
            color: #8B4513; 
            font-weight: bold; 
        }
        
        .log-heroico { 
            color: #006400; 
            font-weight: bold; 
        }
        
        .log-deshonroso { 
            color: #8B0000; 
            font-weight: bold; 
        }
        
        .log-publico { 
            color: #3a2c0e; 
            font-style: italic; 
        }
        
        .log-efecto { 
            color: #3a2c0e; 
        }
        
        .log-critical { 
            color: #8B0000; 
            font-weight: bold; 
            animation: blink 0.5s infinite; 
        }
        
        .log-apuesta { 
            color: #006400; 
            font-weight: bold; 
        }
        
        .log-center { 
            color: #3a2c0e; 
        }
        
        .log-speaker { 
            color: #8B4513; 
            font-weight: bold; 
            font-style: italic; 
        }
        
        .log-blink { 
            animation: blink 0.5s infinite; 
        }
        
        /* ANIMACIÓN DE PARPADEO */
        @keyframes blink { 
            0% { color: #8b0000; } 
            50% { color: #FFCCCB; } 
            100% { color: #8b0000; } 
        }
        
        /* TOKENS DE ENEMIGOS */
        .enemy-token { 
            border-radius: 5px; 
            display: flex; 
            align-items: end; 
            justify-content: center; 
            font-weight: bold; 
            color: white; 
            text-shadow: 1px 1px 2px black; 
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.7); 
            animation: appear 0.5s ease-out; 
            cursor: pointer; 
            transition: transform 0.2s; 
            background-size: contain; 
            background-position: center; 
            background-repeat: no-repeat; 
            border: 2px solid #8B4513; 
        }
        
        .enemy-token.normal { 
            font-size: 1.8vmin; 
        }
        
        .enemy-token.enorme { 
            font-size: 1.4vmin; 
            z-index: 3;
            border: 3px solid #8B4513;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.9);
        }
        
        .enemy-token.extraenorme { 
            font-size: 1.2vmin; 
            z-index: 4;
            box-shadow: 0 0 10px rgba(0, 0, 0, 1); 
        }
        
        .enemy-token:hover { 
            transform: scale(1.1); 
        }
        
        /* ANIMACIÓN DE APARICIÓN */
        @keyframes appear { 
            from { opacity: 0; transform: scale(0) rotate(-10deg); } 
            to { opacity: 1; transform: scale(1) rotate(0deg); } 
        }
        
        /* BOTÓN DE CERRAR CUADRICULA - MEJORADO Y VISIBLE */
        #close-grid { 
            position: absolute; 
            top: -12px; 
            right: -12px; 
            width: 30px; 
            height: 30px; 
            border-radius: 50%; 
            background-color: #8B0000; 
            color: white; 
            border: 2px solid #d4af37; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            cursor: pointer; 
            z-index: 101; 
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
            font-size: 16px;
        }
        
        #close-grid:hover { 
            background-color: #FF0000; 
            border: 2px solid #FFD700; 
            transform: scale(1.1);
        }
        
        /* MEDIA QUERIES PARA RESPONSIVIDAD */
        
        /* Tablets (hasta 1200px) */
        @media (max-width: 1200px) { 
            #event-log { 
                font-size: 0.9rem; 
            } 
            
            .config-label { 
                font-size: 1.5rem; 
            } 
            
            #grid-container { 
                width: 78vmin; 
                height: 58.5vmin; 
            }
            
            .btn {
                width: 50px;
                height: 50px;
            }
            
            .main-btn {
                width: 70px;
                height: 70px;
            }
        }
        
        /* Tablets pequeñas y móviles en horizontal (hasta 768px) */
        @media (max-width: 768px) { 
            #app-container {
                padding: 10px;
            }
            
            .titulo-container {
                height: 120px;
            }
            
            #top-panel {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            
            .config-group {
                width: 100%;
            }
            
            #log-container {
                height: 200px;
            }
            
            #event-log { 
                font-size: 0.8rem;
                padding: 10px;
            }
            
            .config-label { 
                font-size: 1.2rem; 
            }
            
            .btn { 
                width: 40px;
                height: 40px;
            }
            
            #main-buttons { 
                gap: 10px;
                padding: 10px;
            }
            
            .main-btn {
                width: 60px;
                height: 60px;
            }
            
            #grid-container { 
                width: 95vmin;
                height: 71.25vmin;
            }
            
            #nivel-arena-label { 
                font-size: 1rem;
                padding: 8px 16px;
            }
        }
        
        /* Móviles (hasta 480px) */
        @media (max-width: 480px) { 
            .titulo-container {
                height: 100px;
            }
            
            #log-container {
                height: 180px;
                background-size: cover;
            }
            
            #event-log { 
                font-size: 0.7rem;
                width: 90%;
                height: 85%;
            }
            
            .config-label { 
                font-size: 1.1rem; 
            }
            
            .btn { 
                width: 35px;
                height: 35px;
            }
            
            #main-buttons { 
                gap: 8px;
            }
            
            .main-btn {
                width: 50px;
                height: 50px;
            }
            
            #grid-container { 
                width: 95vmin;
                height: 71.25vmin;
            }
            
            #nivel-arena-label { 
                font-size: 0.9rem;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div class="header-container">
            <div class="titulo-container"></div>
        </div>
        
        <div id="top-panel">
            <div class="config-group">
                <div class="config-title">Nivel de Héroes</div>
                <div id="nivel-panel" class="config-panel">
                    <button id="btn-nivel-down" class="btn" style="background-image: url('assets/imagenes/btn_nivel_down.png')"></button>
                    <div id="nivel-label" class="config-label">1</div>
                    <button id="btn-nivel-up" class="btn" style="background-image: url('assets/imagenes/btn_nivel_up.png')"></button>
                </div>
            </div>
            
            <div class="config-group">
                <div class="config-title">Arena</div>
                <select id="select-arena" class="select-arena">
                    <option value="">Cargando arenas...</option>
                </select>
            </div>
            
            <div id="nivel-arena-container">
                <div id="nivel-arena-label">Nivel arena COBRE</div>
            </div>
            
            <div class="config-group">
                <div class="config-title">Apuesta</div>
                <div id="apuesta-panel" class="config-panel">
                    <button id="btn-apuesta-down" class="btn" style="background-image: url('assets/imagenes/btn_apuesta_down.png')"></button>
                    <div id="apuesta-label" class="config-label">0</div>
                    <button id="btn-apuesta-up" class="btn" style="background-image: url('assets/imagenes/btn_apuesta_up.png')"></button>
                </div>
            </div>
        </div>
        
        <div id="log-container">
            <div id="event-log"></div>
        </div>
        
        <div id="main-buttons">
            <button id="btn-iniciar" class="btn main-btn" style="background-image: url('assets/imagenes/btn_iniciar.png')"></button>
            <button id="btn-ronda" class="btn main-btn" style="background-image: url('assets/imagenes/btn_ronda.png')" disabled></button>
            <button id="btn-heroico" class="btn main-btn" style="background-image: url('assets/imagenes/btn_heroico.png')" disabled></button>
            <button id="btn-deshonroso" class="btn main-btn" style="background-image: url('assets/imagenes/btn_deshonroso.png')" disabled></button>
            <button id="btn-musica-on" class="btn main-btn" style="background-image: url('assets/imagenes/btn_con_musica.png')"></button>
            <button id="btn-musica-off" class="btn main-btn" style="background-image: url('assets/imagenes/btn_sin_musica.png'); display:none;"></button>
            <button id="btn-reiniciar" class="btn main-btn" style="background-image: url('assets/imagenes/btn_reiniciar.png')"></button>
            <button id="btn-reglas" class="btn main-btn" style="background-image: url('assets/imagenes/btn_reglas.png')"></button>
        </div>
        
        <div id="grid-section">
            <h3 class="grid-title">Zona de Combate Enemiga</h3>
            <div id="grid-container">
                <div id="grid-content"></div>
                <div id="close-grid">X</div>
            </div>
        </div>
    </div>

    <script>
        class ArenaApp {
            constructor() {
                this._setupAttributes();
                this.init();  
            }
            
            _setupAttributes() {
                this.BASE_DIR = window.location.href.replace(/\/[^\/]*$/, '');
                this.IMAGES_DIR = `${this.BASE_DIR}/assets/imagenes`;
                this.AUDIO_DIR = `${this.BASE_DIR}/assets/audio`;
                this.DATA_DIR = `${this.BASE_DIR}/assets/data`;
                this.TOKENS_DIR = `${this.BASE_DIR}/assets/tokens`;
                
                this.ui_config = null;
                this.estados_config = null;
                this.descansos = null;
                this.recompensas = null;
                this.comportamiento = null;
                this.arenas = null;
                this.arenaActual = null;
                
                this.heroes_nivel = null;
                this.ronda_actual = 1;
                this.encuentro_actual = null;
                this.encuentros = {};
                this.acciones_heroicas = 0;
                this.acciones_deshonrosas = 0;
                this.moral_grupo = 0;
                this.cordura = 0;
                this.bonif_critico = false;
                this.apuesta_activa = false;
                this.apuesta_monedas = 0;
                this.reward_log_visible = false;
                this.exp_total_acumulada = 0;
                
                this.musica_activada = true;
                this.audioContext = null;
                this.audioElement = null;
                this.audioGain = null;
                
                this.nivel_valor = 1;
                this.apuesta_valor = 0;
                
                this.blink_state = false;
                this.blink_interval = null;
                
                this.gridVisible = false;
                this.enemyTokens = [];
                this.enemigosProcesados = [];
                
                // Nuevas propiedades para manejar el tamaño del grid
                this.gridAspectRatio = 4/3; // Relación de aspecto por defecto (4:3)
            }
            
            async init() {
                try {
                    await this.cargarConfiguraciones();
                    await this.cargarArenas();
                    this.inicializarUI();
                    this.inicializarEstados();
                    this.inicializarMusica();
                    this.mostrarMensajeBienvenida();
                    this.iniciarEfectoParpadeo();
                    this.configurarEventos();
                    
                    window.addEventListener('resize', () => this.ajustarUIResponsive());
                    this.ajustarUIResponsive();
                    this.inicializarGrid();
                    this.actualizarNivelArena();
                    
                    // Nueva validación inicial
                    this.validarEstadoArena();
                } catch (error) {
                    console.error("Error inicializando la aplicación:", error);
                    this.mostrarMensajeLog(`Error al inicializar: ${error.message}`, 'enemigo');
                }
            }
            
            async cargarArenas() {
                try {
                    const response = await fetch(`${this.DATA_DIR}/arenas.json`);
                    if (!response.ok) throw new Error("No se pudo cargar arenas.json");
                    
                    const data = await response.json();
                    this.arenas = data.arenas;
                    
                    // Poblar el selector de arenas
                    const selectArena = document.getElementById('select-arena');
                    selectArena.innerHTML = '';
                    
                    // Añadir opción por defecto que obligue a seleccionar
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = '-- SELECCIONA UNA ARENA --';
                    defaultOption.disabled = true;
                    defaultOption.selected = true;
                    selectArena.appendChild(defaultOption);
                    
                    this.arenas.forEach(arena => {
                        const option = document.createElement('option');
                        option.value = arena.nombre;
                        option.textContent = arena.nombre;
                        selectArena.appendChild(option);
                    });
                    
                    // Establecer la arena por defecto (si existe) pero mantener selección forzada
                    if (this.arenas.length > 0) {
                        this.arenaActual = null; // Inicialmente null hasta que usuario seleccione
                    }
                    
                    // Event listener para cambiar de arena
                    selectArena.addEventListener('change', (e) => {
                        const nombreArena = e.target.value;
                        if (nombreArena) {
                            this.cambiarArena(nombreArena);
                        } else {
                            this.arenaActual = null;
                            this.validarEstadoArena(); // Validar estado después del cambio
                        }
                    });
                    
                } 
                
                catch (error) {
                    console.error("Error cargando arenas:", error);
         
                    }
            }
            
            async cambiarArena(nombreArena) {
                const arena = this.arenas.find(a => a.nombre === nombreArena);
                if (!arena) {
                    this.arenaActual = null;
                    this.validarEstadoArena();
                    return;
                }
                
                this.arenaActual = arena;
                this.limpiarGrid();
                
                // Cargar la imagen para obtener sus dimensiones
                if (arena.imagen) {
                    await this.ajustarGridASize(arena.imagen);
                    document.getElementById('grid-container').style.backgroundImage = `url('${this.IMAGES_DIR}/${arena.imagen}')`;
                }
                
                this.crearGridDesdeMatriz(arena.matriz);
                this.mostrarMensajeLog(`Arena cambiada a: ${arena.nombre}`, 'publico');
                
                // Validar estado después de cambiar arena
                this.validarEstadoArena();
            }

            validarEstadoArena() {
                const btnIniciar = document.getElementById('btn-iniciar');
                const tieneArenaSeleccionada = this.arenaActual !== null;
                
                // Habilitar/deshabilitar botón según si hay arena seleccionada
                btnIniciar.disabled = !tieneArenaSeleccionada;
                
                // También actualizar tooltip o mensaje de estado si quieres
                if (!tieneArenaSeleccionada) {
                    btnIniciar.title = "Selecciona una arena primero";
                } else {
                    btnIniciar.title = "Iniciar arena";
                }
            }
            
            // Nueva función para ajustar el tamaño del grid según la imagen
            async ajustarGridASize(imagenNombre) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        // Calcular la relación de aspecto de la imagen
                        this.gridAspectRatio = img.width / img.height;
                        
                        // Ajustar el tamaño del contenedor del grid
                        const gridContainer = document.getElementById('grid-container');
                        const maxWidth = Math.min(800, window.innerWidth * 0.9);
                        const width = maxWidth;
                        const height = width / this.gridAspectRatio;
                        
                        gridContainer.style.width = `${width}px`;
                        gridContainer.style.height = `${height}px`;
                        
                        resolve();
                    };
                    img.onerror = () => {
                        // Si hay error al cargar la imagen, usar relación de aspecto por defecto
                        console.warn("No se pudo cargar la imagen para calcular la relación de aspecto");
                        this.gridAspectRatio = 4/3; // Relación por defecto 4:3
                        resolve();
                    };
                    img.src = `${this.IMAGES_DIR}/${imagenNombre}`;
                });
            }
            
            crearGridDesdeMatriz(matriz) {
                const gridContent = document.getElementById('grid-content');
                gridContent.innerHTML = '';
                
                // Establecer el número de columnas y filas según la matriz
                const columnas = matriz[0].length;
                const filas = matriz.length;
                
                gridContent.style.gridTemplateColumns = `repeat(${columnas}, 1fr)`;
                gridContent.style.gridTemplateRows = `repeat(${filas}, 1fr)`;
                
                // Crear las celdas
                for (let i = 0; i < filas; i++) {
                    for (let j = 0; j < columnas; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        if (matriz[i][j] === 0) {
                            cell.classList.add('invalida');
                        }
                        gridContent.appendChild(cell);
                    }
                }
            }
            
            inicializarGrid() {
                const gridContainer = document.getElementById('grid-container');
                const closeButton = document.getElementById('close-grid');
                
                // Crear grid por defecto si no hay arena actual
                if (!this.arenaActual) {
                    const matrizPorDefecto = Array(6).fill().map(() => Array(8).fill(1));
                    this.crearGridDesdeMatriz(matrizPorDefecto);
                } else {
                    this.crearGridDesdeMatriz(this.arenaActual.matriz);
                }
                
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.ocultarGrid();
                });
                
                gridContainer.addEventListener('mousedown', (e) => {
                    if (e.target === gridContainer || e.target === gridContent) {
                        this.isDragging = true;
                        this.dragOffset = { x: e.clientX - gridContainer.offsetLeft, y: e.clientY - gridContainer.offsetTop };
                        gridContainer.style.cursor = 'grabbing';
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        // Limitar el movimiento al área del panel derecho
                        const rightPanel = document.getElementById('right-panel');
                        const rightPanelRect = rightPanel.getBoundingClientRect();
                        const gridRect = gridContainer.getBoundingClientRect();
                        
                        let newLeft = e.clientX - this.dragOffset.x;
                        let newTop = e.clientY - this.dragOffset.y;
                        
                        // Limitar a los bordes del panel derecho
                        newLeft = Math.max(rightPanelRect.left, Math.min(newLeft, rightPanelRect.right - gridRect.width));
                        newTop = Math.max(rightPanelRect.top, Math.min(newTop, rightPanelRect.bottom - gridRect.height));
                        
                        gridContainer.style.left = newLeft + 'px';
                        gridContainer.style.top = newTop + 'px';
                        gridContainer.style.transform = 'none';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    gridContainer.style.cursor = 'move';
                });
                
                gridContainer.addEventListener('touchstart', (e) => {
                    if (e.target === gridContainer || e.target === gridContent) {
                        this.isDragging = true;
                        const touch = e.touches[0];
                        this.dragOffset = { x: touch.clientX - gridContainer.offsetLeft, y: touch.clientY - gridContainer.offsetTop };
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (this.isDragging) {
                        const touch = e.touches[0];
                        
                        // Limitar el movimiento al área del panel derecho
                        const rightPanel = document.getElementById('right-panel');
                        const rightPanelRect = rightPanel.getBoundingClientRect();
                        const gridRect = gridContainer.getBoundingClientRect();
                        
                        let newLeft = touch.clientX - this.dragOffset.x;
                        let newTop = touch.clientY - this.dragOffset.y;
                        
                        // Limitar a los bordes del panel derecho
                        newLeft = Math.max(rightPanelRect.left, Math.min(newLeft, rightPanelRect.right - gridRect.width));
                        newTop = Math.max(rightPanelRect.top, Math.min(newTop, rightPanelRect.bottom - gridRect.height));
                        
                        gridContainer.style.left = newLeft + 'px';
                        gridContainer.style.top = newTop + 'px';
                        gridContainer.style.transform = 'none';
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('touchend', () => this.isDragging = false);
            }

            limpiarGrid() {
                this.enemyTokens.forEach(token => token.remove());
                this.enemyTokens = [];
                
                document.querySelectorAll('.grid-cell').forEach(cell => {
                    while (cell.firstChild) cell.removeChild(cell.firstChild);
                });
            }
            
            mostrarGridConEnemigos(enemigos) {
                this.limpiarGrid();
                this.enemigosProcesados = enemigos;
                
                const gridContainer = document.getElementById('grid-container');
                
                const obtenerDimensiones = (tamano) => {
                    switch (tamano) {
                        case 'ENORME': return { ancho: 2, alto: 2 };
                        case 'EXTRAENORME': return { ancho: 3, alto: 2 };
                        default: return { ancho: 1, alto: 1 };
                    }
                };
                
                // Obtener dimensiones de la arena actual
                const filas = this.arenaActual.matriz.length;
                const columnas = this.arenaActual.matriz[0].length;
                
                // Función para verificar si un área está disponible
                const areaDisponible = (inicioIndex, ancho, alto) => {
                    const inicioFila = Math.floor(inicioIndex / columnas);
                    const inicioColumna = inicioIndex % columnas;
                    
                    // Verificar que no se sale de los límites
                    if (inicioFila + alto > filas || inicioColumna + ancho > columnas) {
                        return false;
                    }
                    
                    // Verificar que todas las celdas del área estén disponibles y sean válidas
                    for (let fila = 0; fila < alto; fila++) {
                        for (let columna = 0; columna < ancho; columna++) {
                            const celdaIndex = (inicioFila + fila) * columnas + (inicioColumna + columna);
                            const celda = document.querySelectorAll('.grid-cell')[celdaIndex];
                            
                            if (!celda || celda.classList.contains('invalida') || celda.classList.contains('ocupada')) {
                                return false;
                            }
                        }
                    }
                    
                    return true;
                };
                
                // Función para reservar un área
                const reservarArea = (inicioIndex, ancho, alto) => {
                    const inicioFila = Math.floor(inicioIndex / columnas);
                    const inicioColumna = inicioIndex % columnas;
                    const celdasReservadas = [];
                    
                    for (let fila = 0; fila < alto; fila++) {
                        for (let columna = 0; columna < ancho; columna++) {
                            const celdaIndex = (inicioFila + fila) * columnas + (inicioColumna + columna);
                            const celda = document.querySelectorAll('.grid-cell')[celdaIndex];
                            
                            if (celda) {
                                celda.classList.add('ocupada');
                                celdasReservadas.push(celdaIndex);
                            }
                        }
                    }
                    
                    return celdasReservadas;
                };
                
                // Obtener todas las posiciones disponibles (células válidas y no ocupadas)
                let posicionesDisponibles = [];
                document.querySelectorAll('.grid-cell:not(.invalida):not(.ocupada)').forEach((celda, index) => {
                    posicionesDisponibles.push(index);
                });
                
                // Ordenar enemigos por tamaño (los más grandes primero)
                enemigos.sort((a, b) => {
                    const tamanoA = this.obtenerTamanoMonstruo(a.nombre);
                    const tamanoB = this.obtenerTamanoMonstruo(b.nombre);
                    
                    const prioridad = { "EXTRAENORME": 3, "ENORME": 2, "NORMAL": 1 };
                    return prioridad[tamanoB] - prioridad[tamanoA];
                });
                
                enemigos.forEach(enemigo => {
                    if (posicionesDisponibles.length === 0) return;
                    
                    const tamano = this.obtenerTamanoMonstruo(enemigo.nombre);
                    const dimensiones = obtenerDimensiones(tamano);
                    
                    for (let i = 0; i < enemigo.cantidad; i++) {
                        if (posicionesDisponibles.length === 0) break;
                        
                        let posicionValida = false;
                        let intentos = 0;
                        let posIndex, cellIndex;
                        
                        // Buscar una posición válida
                        while (!posicionValida && intentos < 100 && posicionesDisponibles.length > 0) {
                            posIndex = Math.floor(Math.random() * posicionesDisponibles.length);
                            cellIndex = posicionesDisponibles[posIndex];
                            
                            // Verificar si el área está disponible
                            posicionValida = areaDisponible(cellIndex, dimensiones.ancho, dimensiones.alto);
                            
                            if (!posicionValida) {
                                intentos++;
                                // Remover esta celda de las disponibles si no es válida
                                const indexToRemove = posicionesDisponibles.indexOf(cellIndex);
                                if (indexToRemove !== -1) {
                                    posicionesDisponibles.splice(indexToRemove, 1);
                                }
                            }
                        }
                        
                        if (!posicionValida) {
                            // Si no encontramos posición después de muchos intentos, saltamos este enemigo
                            console.warn(`No se pudo colocar al enemigo: ${enemigo.nombre}`);
                            continue;
                        }
                        
                        // Reservar el área completa
                        reservarArea(cellIndex, dimensiones.ancho, dimensiones.alto);
                        
                        const inicioFila = Math.floor(cellIndex / columnas);
                        const inicioColumna = cellIndex % columnas;
                        
                        const token = document.createElement('div');
                        token.className = 'enemy-token';
                        token.classList.add(tamano.toLowerCase());
                        
                        // Obtener y establecer la imagen del token
                        const imagenToken = this.obtenerImagenToken(enemigo.nombre);
                        token.style.backgroundImage = `url('${imagenToken}')`;
                        
                        const cellWidth = 100 / columnas;
                        const cellHeight = 100 / filas;
                        
                        token.style.position = 'absolute';
                        token.style.width = `${cellWidth * dimensiones.ancho}%`;
                        token.style.height = `${cellHeight * dimensiones.alto}%`;
                        token.style.left = `${inicioColumna * cellWidth}%`;
                        token.style.top = `${inicioFila * cellHeight}%`;
                        
                        token.textContent = this.obtenerAbreviatura(enemigo.nombre);
                        token.title = `${enemigo.nombre} (${tamano})`;
                        
                        document.getElementById('grid-content').appendChild(token);
                        this.enemyTokens.push(token);
                    }
                });
                
                document.getElementById('grid-container').classList.add('visible');
                this.gridVisible = true;
            }

            
            obtenerImagenToken(nombre) {
                if (!this.monstruos_imagenes || !this.monstruos_imagenes.mapeo_imagenes) {
                    return `${this.TOKENS_DIR}/default.png`;
                }
                
                // Primero, convertir a minúsculas y limpiar el nombre
                let nombreLimpio = nombre.toLowerCase().trim();
                
                // Si el nombre contiene un número al inicio, eliminarlo (ej: "2 lobos temibles" -> "lobos temibles")
                nombreLimpio = nombreLimpio.replace(/^\d+\s+/, '');
                  // Normalizar ñ -> n para coincidencias
                nombreLimpio = nombreLimpio.replace(/ñ/g, 'n');

                nombreLimpio = nombreLimpio
                    .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Eliminar tildes
                    .replace(/[^a-z0-9\s]/g, "") // Eliminar caracteres especiales
                    .replace(/\s+/g, ' '); // Espacios múltiples a uno
                
                // Buscar si el nombre está en el diccionario de plurales
                if (this.monstruos_imagenes.plurales) {
                    for (const [plural, singular] of Object.entries(this.monstruos_imagenes.plurales)) {
                        if (nombreLimpio === plural) {
                            nombreLimpio = singular;
                            break;
                        }
                    }
                }
                
                // Si no se encontró en el diccionario, aplicar reglas generales
                if (nombreLimpio.endsWith('es')) {
                    nombreLimpio = nombreLimpio.slice(0, -2);
                } else if (nombreLimpio.endsWith('s')) {
                    nombreLimpio = nombreLimpio.slice(0, -1);
                }
                
                // Obtener todas las claves y ordenarlas de más largas a más cortas
                // Esto asegura que "goblin chamán" se busque antes que "goblin"
                const clavesOrdenadas = Object.keys(this.monstruos_imagenes.mapeo_imagenes)
                    .sort((a, b) => b.length - a.length);
                
                // Buscar coincidencia en el mapeo (empezando por las claves más largas)
                for (const clave of clavesOrdenadas) {
                    if (nombreLimpio.includes(clave)) {
                        return `${this.TOKENS_DIR}/${this.monstruos_imagenes.mapeo_imagenes[clave]}`;
                    }
                }
                
                // Imagen por defecto si no se encuentra coincidencia
                return `${this.TOKENS_DIR}/default.png`;
            }

            obtenerTipoEnemigo(nombre) {
                nombre = nombre.toLowerCase();
                if (nombre.includes('goblin') || nombre.includes('orco') || nombre.includes('ogro')) return 'humanoide';
                else if (nombre.includes('esqueleto') || nombre.includes('zombi') || nombre.includes('muerto')) return 'no-muerto';
                else if (nombre.includes('dragón') || nombre.includes('wyvern') || nombre.includes('grifo')) return 'dragón';
                else if (nombre.includes('demonio') || nombre.includes('diablo') || nombre.includes('infernal')) return 'demonio';
                else if (nombre.includes('lobo') || nombre.includes('rata') || nombre.includes('araña')) return 'bestia';
                else if (nombre.includes('hechicero') || nombre.includes('mago') || nombre.includes('brujo')) return 'magico';
                else return 'otros';
            }
            
            obtenerColorPorTipo(tipo) {
                const colores = {
                    'humanoide': '#8B4513', 'no-muerto': '#696969', 'dragón': '#B22222',
                    'demonio': '#4B0082', 'bestia': '#556B2F', 'magico': '#9370DB', 'otros': '#2F4F4F'
                };
                return colores[tipo] || '#2F4F4F';
            }
            
            obtenerAbreviatura(nombre) {
                if (nombre.length <= 3) return nombre.substring(0, 3);
                const palabras = nombre.split(' ');
                if (palabras.length > 1) return palabras.map(p => p[0]).join('').toUpperCase().substring(0, 3);
                return nombre.substring(0, 3).toUpperCase();
            }
            
            
            
            ajustarUIResponsive() {
                const eventLog = document.getElementById('event-log');
                if (window.innerWidth > 1000) eventLog.style.fontSize = '14px';
                
                // Ajustar el tamaño del grid si hay una arena actual
                if (this.arenaActual && this.arenaActual.imagen) {
                    this.ajustarGridASize(this.arenaActual.imagen);
                }
            }
            
            async cargarConfiguraciones() {
                try {
                    this.BASE_DIR = window.location.href.replace(/\/[^\/]*$/, '');
                    this.IMAGES_DIR = `${this.BASE_DIR}/assets/imagenes`;
                    this.AUDIO_DIR = `${this.BASE_DIR}/assets/audio`;
                    this.DATA_DIR = `${this.BASE_DIR}/assets/data`;
                    this.TOKENS_DIR = `${this.BASE_DIR}/assets/tokens`;
                    
                    const configFiles = ['ui_config.json', 'estados.json', 'descansos.json', 'recompensas.json', 'comportamiento.json'];
                    
                    // Cargar archivos de configuración principales
                    const [uiConfig, estadosConfig, descansosConfig, recompensasConfig, comportamientoConfig] = await Promise.all(
                        configFiles.map(file => 
                            fetch(`${this.DATA_DIR}/${file}`)
                                .then(response => {
                                    if (!response.ok) throw new Error(`No se pudo cargar ${file}`);
                                    return response.json();
                                })
                                .catch(error => {
                                    console.error(`Error cargando ${file}:`, error);
                                    return {};
                                })
                        )
                    );
                    
                    // Cargar archivos específicos de monstruos
                    const [tamanosResponse, monstruosExpResponse, monstruosImagenesResponse] = await Promise.all([
                        fetch(`${this.DATA_DIR}/encuentros/tamanos_monstruos.json`),
                        fetch(`${this.DATA_DIR}/encuentros/monstruos-exp.json`),
                        fetch(`${this.DATA_DIR}/monstruos-imagenes.json`)
                    ]);
                    
                    if (!tamanosResponse.ok) throw new Error("No se pudo cargar tamanos_monstruos.json");
                    if (!monstruosExpResponse.ok) throw new Error("No se pudo cargar monstruos-exp.json");
                    if (!monstruosImagenesResponse.ok) throw new Error("No se pudo cargar monstruos-imagenes.json");
                    
                    this.tamanos_monstruos = await tamanosResponse.json();
                    this.monstruos_exp = await monstruosExpResponse.json();
                    this.monstruos_imagenes = await monstruosImagenesResponse.json();
                    
                    this.ui_config = uiConfig || {};
                    this.estados_config = estadosConfig || {limites: {moral_max: 100, cordura_max: 100}};
                    this.descansos = descansosConfig || {};
                    this.recompensas = recompensasConfig || {};
                    this.comportamiento = comportamientoConfig || {};
                    
                    await this.cargarEncuentros();
                    
                } catch (e) {
                    console.error("Error cargando configuraciones:", e);
                    this.mostrarMensajeLog(`Error: ${e.message}`, 'enemigo');
                    this.ui_config = {};
                    this.estados_config = {limites: {moral_max: 100, cordura_max: 100}};
                    this.descansos = {};
                    this.recompensas = {};
                    this.comportamiento = {};
                    this.monstruos_exp = {monstruos: []};
                    this.monstruos_imagenes = {mapeo_imagenes: {}, plurales: {}};
                    this.tamanos_monstruos = {tamaños: {}};
                }
            }

            
            async cargarEncuentros() {
                try {
                    let archivoEncuentros = '';
                    if (this.nivel_valor <= 2) archivoEncuentros = 'nivel_1_2.json';
                    else if (this.nivel_valor <= 4) archivoEncuentros = 'nivel_3_4.json';
                    else if (this.nivel_valor <= 6) archivoEncuentros = 'nivel_5_6.json';
                    else archivoEncuentros = 'nivel_7_8.json';
                    
                    const response = await fetch(`${this.DATA_DIR}/encuentros/${archivoEncuentros}`);
                    if (!response.ok) throw new Error(`No se pudo cargar ${archivoEncuentros}`);
                    
                    this.encuentros = await response.json();
                } catch (e) {
                    console.error("Error cargando encuentros:", e);
                    this.mostrarMensajeLog(`No se pudo cargar los encuentros: ${e.message}`, 'enemigo');
                    this.encuentros = {};
                }
            }

            
            inicializarUI() {
                this.cargarImagenesBotones();
                this.configurarEventosBotones();   
            }

            obtenerTamanoMonstruo(nombre) {
                if (this.tamanos_monstruos.tamaños && this.tamanos_monstruos.tamaños[nombre]) {
                    return this.tamanos_monstruos.tamaños[nombre];
                }
                
                for (const key in this.tamanos_monstruos.tamaños) {
                    if (nombre.includes(key) || key.includes(nombre)) {
                        return this.tamanos_monstruos.tamaños[key];
                    }
                }
                
                return "NORMAL";
            }
            
            cargarImagenesBotones() {
                const botonesConfig = {
                    'btn-nivel-down': 'btn_nivel_down.png', 'btn-nivel-up': 'btn_nivel_up.png',
                    'btn-apuesta-down': 'btn_apuesta_down.png', 'btn-apuesta-up': 'btn_apuesta_up.png',
                    'btn-iniciar': 'btn_iniciar.png', 'btn-ronda': 'btn_ronda.png',
                    'btn-heroico': 'btn_heroico.png', 'btn-deshonroso': 'btn_deshonroso.png',
                    'btn-musica-on': 'btn_con_musica.png', 'btn-musica-off': 'btn_sin_musica.png',
                    'btn-reiniciar': 'btn_reiniciar.png', 'btn-reglas': 'btn_reglas.png'
                };
                
                for (const [id, imagen] of Object.entries(botonesConfig)) {
                    const btn = document.getElementById(id);
                    if (btn) btn.style.backgroundImage = `url('${this.IMAGES_DIR}/${imagen}')`;
                }
            }
            
            configurarEventosBotones() {
                document.getElementById('btn-nivel-up').addEventListener('click', () => this.incrementarNivel());
                document.getElementById('btn-nivel-down').addEventListener('click', () => this.decrementarNivel());
                document.getElementById('btn-apuesta-up').addEventListener('click', () => this.incrementarApuesta());
                document.getElementById('btn-apuesta-down').addEventListener('click', () => this.decrementarApuesta());
                document.getElementById('btn-iniciar').addEventListener('click', () => this.iniciarArena());
                document.getElementById('btn-ronda').addEventListener('click', () => this.siguienteRonda());
                document.getElementById('btn-heroico').addEventListener('click', () => this.evaluarAccion('heroica'));
                document.getElementById('btn-deshonroso').addEventListener('click', () => this.evaluarAccion('deshonrosa'));
                document.getElementById('btn-reiniciar').addEventListener('click', () => this.reiniciarArena());
                document.getElementById('btn-reglas').addEventListener('click', () => this.mostrarReglas());
                document.getElementById('btn-musica-on').addEventListener('click', () => this.desactivarMusica());
                document.getElementById('btn-musica-off').addEventListener('click', () => this.activarMusica());
            }
            
            
            
            inicializarEstados() {
                const limites = this.estados_config.limites || {};
                this.moral_grupo = limites.moral_max || 10;
                this.cordura = limites.cordura_max || 10;
                
                this.heroes_nivel = null;
                this.ronda_actual = 1;
                this.encuentro_actual = null;
                this.encuentros = {};
                this.acciones_heroicas = 0;
                this.acciones_deshonrosas = 0;
                this.bonif_critico = false;
                this.apuesta_activa = false;
                this.apuesta_monedas = 0;
                this.reward_log_visible = false;
                this.exp_total_acumulada = 0;
            }
            
            inicializarMusica() {
                this.audioElement = new Audio(`${this.AUDIO_DIR}/musica_fondo.mp3`);
                this.audioElement.loop = true;
                this.audioElement.volume = 0.7;
                this.audioElement.play().catch(e => console.log("Error al reproducir música automáticamente:", e));
            }
            
            mostrarMensajeBienvenida() {
                this.mostrarMensajeLog("\n=== BIENVENIDO A LA ARENA DE LORAINIA ===", 'titulo');
                this.mostrarMensajeLog("¡Atención, ciudadanos de Lorainia! Aventureros de las Tierras Antiguas,\n"
                                     + "estáis bajo la atenta mirada de los dioses y del gran rey Logan III.", 'publico');
                this.mostrarMensajeLog("Reglamento escrito por José Manuel Arena v1.4 y aplicacion por Omar Nieto (DETION)", 'enemigo');
            }
            
            iniciarEfectoParpadeo() {
                this.blink_interval = setInterval(() => this.blink_state = !this.blink_state, 500);
            }
            
            configurarEventos() {}
            
            incrementarNivel() {
                if (this.nivel_valor < 10) {
                    this.nivel_valor++;
                    document.getElementById('nivel-label').textContent = this.nivel_valor;
                    this.actualizarNivelArena();
                }
            }
            
            decrementarNivel() {
                if (this.nivel_valor > 1) {
                    this.nivel_valor--;
                    document.getElementById('nivel-label').textContent = this.nivel_valor;
                    this.actualizarNivelArena();
                }
            }

            actualizarNivelArena() {
                let nivelArena = "", color = "";
                if (this.nivel_valor <= 2) { nivelArena = "COBRE"; color = "#CD7F32"; }
                else if (this.nivel_valor <= 4) { nivelArena = "BRONCE"; color = "#B87333"; }
                else if (this.nivel_valor <= 6) { nivelArena = "PLATA"; color = "#C0C0C0"; }
                else { nivelArena = "ORO"; color = "#FFD700"; }
                
                const nivelArenaLabel = document.getElementById('nivel-arena-label');
                nivelArenaLabel.textContent = `Nivel arena ${nivelArena}`;
                nivelArenaLabel.style.color = color;
            }
            
            incrementarApuesta() {
                if (this.apuesta_valor < 500) {
                    this.apuesta_valor = Math.min(500, this.apuesta_valor + 10);
                    document.getElementById('apuesta-label').textContent = this.apuesta_valor;
                }
            }
            
            decrementarApuesta() {
                if (this.apuesta_valor > 0) {
                    this.apuesta_valor = Math.max(0, this.apuesta_valor - 10);
                    document.getElementById('apuesta-label').textContent = this.apuesta_valor;
                }
            }
            
            mostrarMensajeLog(mensaje, tipo) {
                const eventLog = document.getElementById('event-log');
                const p = document.createElement('p');
                p.className = `log-${tipo}`;
                p.textContent = mensaje;
                eventLog.appendChild(p);
                eventLog.scrollTop = eventLog.scrollHeight;
            }
            
            activarMusica() {
                this.musica_activada = true;
                document.getElementById('btn-musica-off').style.display = 'none';
                document.getElementById('btn-musica-on').style.display = 'block';
                if (this.audioElement) this.audioElement.play().catch(e => console.log("Error al reactivar música:", e));
            }
            
            desactivarMusica() {
                this.musica_activada = false;
                document.getElementById('btn-musica-on').style.display = 'none';
                document.getElementById('btn-musica-off').style.display = 'block';
                if (this.audioElement) this.audioElement.pause();
            }
            
            reiniciarArena() {
                const eventLog = document.getElementById('event-log');
                eventLog.innerHTML = '';
                this.inicializarEstados();
                
                // RESTAURAR CONTROLES AL REINICIAR
                document.getElementById('btn-iniciar').disabled = false;
                document.getElementById('btn-ronda').disabled = true;
                document.getElementById('btn-heroico').disabled = true;
                document.getElementById('btn-deshonroso').disabled = true;
                document.getElementById('btn-nivel-up').disabled = false;
                document.getElementById('btn-nivel-down').disabled = false;
                document.getElementById('btn-apuesta-up').disabled = false;
                document.getElementById('btn-apuesta-down').disabled = false;
                document.getElementById('select-arena').disabled = false;
                
                this.nivel_valor = 1;
                this.apuesta_valor = 0;
                document.getElementById('nivel-label').textContent = this.nivel_valor;
                document.getElementById('apuesta-label').textContent = this.apuesta_valor;
                if (this.gridVisible) this.ocultarGrid();
                this.mostrarMensajeBienvenida();
            }
            
            mostrarReglas() {
                this.mostrarMensajeLog("\n=== REGLAS DE LA ARENA ===", 'titulo');
                this.mostrarMensajeLog("1. Selecciona el nivel de tus héroes y la apuesta inicial", 'lista');
                this.mostrarMensajeLog("2. Haz clic en 'Iniciar Arena' para comenzar", 'lista');
                this.mostrarMensajeLog("3. En cada ronda, enfrentarás enemigos aleatorios", 'lista');
                this.mostrarMensajeLog("4. Después de cada encuentro, puedes realizar acciones heroicas o deshonrosas", 'lista');
                this.mostrarMensajeLog("5. Gana experiencia y recompensas al completar rondas", 'lista');
                this.mostrarMensajeLog("6. ¡Cuidado con la moral y cordura de tu grupo!", 'lista');
            }
            
            async iniciarArena() {

                if (!this.arenaActual) {
                    this.mostrarMensajeLog("Debes seleccionar una arena primero", 'enemigo');
                    return;
                }

                this.heroes_nivel = this.nivel_valor;
                await this.cargarEncuentros();
                
                // BLOQUEAR CONTROLES AL INICIAR
                document.getElementById('btn-iniciar').disabled = true;
                document.getElementById('btn-ronda').disabled = false;
                document.getElementById('btn-heroico').disabled = false;
                document.getElementById('btn-deshonroso').disabled = false;
                document.getElementById('btn-nivel-up').disabled = true;
                document.getElementById('btn-nivel-down').disabled = true;
                document.getElementById('btn-apuesta-up').disabled = true;
                document.getElementById('btn-apuesta-down').disabled = true;
                document.getElementById('select-arena').disabled = true;
                
                if (this.apuesta_valor > 0) {
                    this.apuesta_activa = true;
                    this.apuesta_monedas = this.apuesta_valor;
                    this.mostrarMensajeLog(`\nHas apostado ${this.apuesta_valor} monedas de oro. ¡Buena suerte!`, 'apuesta');
                }
                
                this.mostrarMensajeLog(`\n=== INICIANDO ARENA NIVEL ${this.nivel_valor} ===`, 'titulo');
                this.mostrarMensajeLog(`Ronda ${this.ronda_actual}`, 'ronda');
                this.ejecutarRonda(this.ronda_actual);
            }
  
            ejecutarRonda(ronda) {
                this.ronda_actual = ronda;
                const tipo_ronda = ronda === 1 ? "Calentamiento" : ronda === 2 ? "Desafío" : "Jefe Final";
                
                if (ronda === 2 || ronda === 3) this.mostrarDescansoCorto();
                
                const encuentros_ronda = this.encuentros[`ronda_${ronda}`];
                if (!encuentros_ronda) {
                    this.mostrarMensajeLog(`No se encontraron encuentros para la ronda ${ronda}`, 'enemigo');
                    return;
                }
                
                const tirada = Math.floor(Math.random() * 100) + 1;
                
                for (const encuentro of encuentros_ronda) {
                    const [rango_min, rango_max] = encuentro.rango.split('-').map(Number);
                    if (tirada >= rango_min && tirada <= rango_max) {
                        this.encuentro_actual = encuentro.enemigos;
                        break;
                    }
                }
                
                if (!this.encuentro_actual && encuentros_ronda.length > 0) {
                    this.encuentro_actual = encuentros_ronda[encuentros_ronda.length - 1].enemigos;
                }
                
                this.mostrarMensajeLog(`\n=== RONDA ${ronda}: ${tipo_ronda.toUpperCase()} ===`, 'ronda');
                this.mostrarMensajeLog(`Tirada: ${tirada}`, 'enemigo');
                this.mostrarEnemigos();
                this.bonif_critico = false;
            }

            mostrarEnemigos() {
                if (!this.encuentro_actual) {
                    this.mostrarMensajeLog("No hay enemigos en esta ronda", 'enemigo');
                    return 0;
                }
                
                const encuentroProcesado = this.procesarExpresionDados(this.encuentro_actual);
                const gruposEnemigos = encuentroProcesado.split(" y ");
                
                this.mostrarMensajeLog("\nENEMIGOS EN LA ARENA:", 'enemigo');
                
                const iconos_enemigos = {
                    "Hechicero": "🧙", "Escudo": "🛡️", "Espada": "⚔️", "Hacha": "⚔️",
                    "Nigromante": "🧙", "Brujo": "🧙", "Chamán": "🧙", "Psíquico": "🧠",
                    "Acechador": "👁️", "Lobo": "🐺", "Rata": "🐀", "Araña": "🕷️",
                    "Ogro": "👹", "Orco": "👹", "Goblin": "👺", "Esqueleto": "💀",
                    "Zombi": "🧟", "Demonio": "😈", "Dragón": "🐲", "Troll": "👹",
                    "Gigante": "👣", "Sátiro": "🐐", "Gárgola": "🗿", "Hidra": "🐍",
                    "Grifo": "🦅", "Wyvern": "🐉", "Vampiro": "🦇", "Momia": "🧟"
                };
                
                let expTotal = 0;
                let expDesglose = [];
                let enemigosParaGrid = [];
                
                for (const grupo of gruposEnemigos) {
                    const grupoTrim = grupo.trim();
                    let cantidad = 1;
                    let nombreCompleto = grupoTrim;
                    let equipamiento = "";
                    
                    // Extraer equipamiento (texto entre paréntesis)
                    const equipamientoMatch = grupoTrim.match(/\((.*?)\)/);
                    if (equipamientoMatch) {
                        equipamiento = equipamientoMatch[1];
                        nombreCompleto = grupoTrim.replace(/\s*\(.*?\)/, '');
                    }
                    
                    const matchCantidad = nombreCompleto.match(/^(\d+)\s+(.+)$/);
                    if (matchCantidad) {
                        cantidad = parseInt(matchCantidad[1]);
                        nombreCompleto = matchCantidad[2];
                    }
                    
                    let nombreLimpio = nombreCompleto.replace(/\s*\(.*\)$/, '')
                        .replace(/\s*\+.*$/, '')
                        .trim();
                    
                    const monstruoInfo = this.buscarMonstruoPorNombre(nombreLimpio);
                    
                    let expMonstruo = 0;
                    if (monstruoInfo) {
                        expMonstruo = monstruoInfo.exp * cantidad;
                        expTotal += expMonstruo;
                        expDesglose.push({ nombre: nombreLimpio, cantidad: cantidad, expIndividual: monstruoInfo.exp, expTotal: expMonstruo });
                    } else {
                        const expPorDefecto = this.nivel_valor * 100;
                        expMonstruo = expPorDefecto * cantidad;
                        expTotal += expMonstruo;
                    }
                    
                    enemigosParaGrid.push({ nombre: nombreLimpio, cantidad: cantidad });
                    
                    let icono = "👹";
                    for (const [tipo, emoji] of Object.entries(iconos_enemigos)) {
                        if (nombreLimpio.includes(tipo)) {
                            icono = emoji;
                            break;
                        }
                    }
                    
                    if (monstruoInfo) {
                        let mensajeEnemigo = `${icono} ${cantidad} ${nombreLimpio} (EXP: ${expMonstruo} = ${cantidad} × ${monstruoInfo.exp})`;
                        if (equipamiento) {
                            mensajeEnemigo += ` - Equipamiento: ${equipamiento}`;
                        }
                        this.mostrarMensajeLog(mensajeEnemigo, 'enemigo');
                    } else {
                        let mensajeEnemigo = `${icono} ${cantidad} ${nombreLimpio} (EXP: ${expMonstruo})`;
                        if (equipamiento) {
                            mensajeEnemigo += ` - Equipamiento: ${equipamiento}`;
                        }
                        this.mostrarMensajeLog(mensajeEnemigo, 'enemigo');
                    }
                }
                
                this.mostrarGridConEnemigos(enemigosParaGrid);
                
                if (expTotal > 0) {
                    this.exp_total_acumulada += expTotal;
                    this.exp_encuentro_actual = expTotal;
                }
                
                return expTotal;
            }
          

            mostrarDescansoCorto() {
                const descanso = this.descansos["corto"];
                if (!descanso) {
                    this.mostrarMensajeLog("No se encontró información de descanso corto", 'enemigo');
                    return;
                }
                
                this.mostrarMensajeLog("\n=== DESCANSO CORTO ===", 'titulo');
                this.mostrarMensajeLog(descanso.descripcion || "Los héroes toman un breve descanso", 'efecto');
                this.mostrarMensajeLog(`Duración: ${descanso.duracion}`, 'efecto');
                this.mostrarMensajeLog("\nBENEFICIOS:", 'titulo');
                
                if (descanso.beneficios && Array.isArray(descanso.beneficios)) {
                    descanso.beneficios.forEach(beneficio => this.mostrarMensajeLog(`• ${beneficio}`, 'lista'));
                }
                
                this.aplicarEfectosDescanso(descanso.efectos);
            }

            aplicarEfectosDescanso(efectos) {
                const limites = this.estados_config.limites || {};
                const moral_max = limites.moral_max || 100;
                const cordura_max = limites.cordura_max || 100;
                
                if (efectos.moral) {
                    this.moral_grupo = Math.min(moral_max, this.moral_grupo + efectos.moral);
                    this.mostrarMensajeLog(`\nMoral del grupo +${efectos.moral}`, 'recompensa');
                }
                
                if (efectos.cordura === "1d3") {
                    const recuperacionCordura = Math.floor(Math.random() * 3) + 1;
                    this.cordura = Math.min(cordura_max, this.cordura + recuperacionCordura);
                    this.mostrarMensajeLog(`Cordura +${recuperacionCordura} (1d3)`, 'recompensa');
                } else if (typeof efectos.cordura === "number") {
                    this.cordura = Math.min(cordura_max, this.cordura + efectos.cordura);
                    this.mostrarMensajeLog(`Cordura +${efectos.cordura}`, 'recompensa');
                }
                
                this.mostrarEstadosActuales();
            }
            
            procesarExpresionDados(expresion, mostrarDetalle = true) {
                const regexDados = /(\d+)d(\d+)([+-]\d+)?/g;
                let resultado = expresion;
                let match;
                
                while ((match = regexDados.exec(expresion)) !== null) {
                    const cantidad = parseInt(match[1]);
                    const caras = parseInt(match[2]);
                    const modificador = match[3] ? parseInt(match[3]) : 0;
                    
                    let total = 0;
                    let tiradas = [];
                    for (let i = 0; i < cantidad; i++) {
                        const tirada = Math.floor(Math.random() * caras) + 1;
                        tiradas.push(tirada);
                        total += tirada;
                    }
                    total += modificador;
                    
                    let textoReemplazo = `${total}`;
                    if (mostrarDetalle && cantidad > 1) {
                        textoReemplazo = `${total} [${match[0]}: ${tiradas.join("+")}${modificador ? modificador : ""}]`;
                    }
                    
                    resultado = resultado.replace(match[0], textoReemplazo);
                }
                
                const regexCantidadFija = /^(\d+)\s+([^0-9].*)$/;
                const matchFijo = resultado.match(regexCantidadFija);
                
                if (matchFijo && !resultado.includes('d')) {
                    const cantidad = parseInt(matchFijo[1]);
                    const nombre = matchFijo[2];
                    resultado = `${cantidad} ${nombre}`;
                }
                
                return resultado;
            }

            buscarMonstruoPorNombre(nombreBuscado) {
                if (!this.monstruos_exp.monstruos || this.monstruos_exp.monstruos.length === 0) return null;
                
                const nombreLimpio = nombreBuscado.trim().toLowerCase()
                    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                    .replace(/[^a-z0-9\s]/g, "")
                    .replace(/\s+/g, ' ');
                
                // PRIMERA BÚSQUEDA: Coincidencia exacta con cualquier forma del nombre
                let monstruo = this.monstruos_exp.monstruos.find(m => {
                    // Modificación: ahora m.nombre puede ser string o array
                    const nombresMonstruo = Array.isArray(m.nombre) ? m.nombre : [m.nombre];
                    
                    return nombresMonstruo.some(nombre => {
                        const nombreMonstruoLimpio = nombre.toLowerCase()
                            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                            .replace(/[^a-z0-9\s]/g, "")
                            .replace(/\s+/g, ' ');
                        return nombreMonstruoLimpio === nombreLimpio;
                    });
                });
                
                if (monstruo) return monstruo;
                
                // SEGUNDA BÚSQUEDA: Coincidencia parcial (incluye o está incluido)
                monstruo = this.monstruos_exp.monstruos.find(m => {
                    const nombresMonstruo = Array.isArray(m.nombre) ? m.nombre : [m.nombre];
                    
                    return nombresMonstruo.some(nombre => {
                        const nombreMonstruoLimpio = nombre.toLowerCase()
                            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                            .replace(/[^a-z0-9\s]/g, "")
                            .replace(/\s+/g, ' ');
                        
                        return nombreLimpio.includes(nombreMonstruoLimpio) || 
                            nombreMonstruoLimpio.includes(nombreLimpio);
                    });
                });
                
                if (monstruo) return monstruo;
                
                // TERCERA BÚSQUEDA: Por palabras clave (tu sistema de respaldo)
                const palabrasClave = {
                    'goblin': 'Goblin', 'zombi': 'Zombi', 'lobo': 'Lobo Gigante', 'bandido': 'Bandido',
                    'brujo': 'Brujo', 'esqueleto': 'Esqueleto', 'orco': 'Orco', 'sátiro': 'Sátiro',
                    'saurio': 'Saurio', 'tumulario': 'Tumulario', 'gnoll': 'Gnoll', 'sanguijuela': 'Sanguijuela Gigante',
                    'necrófago': 'Necrófago', 'hombre bestia': 'Hombre Bestia', 'araña': 'Araña Gigante',
                    'ogro': 'Ogro', 'nigromante': 'Nigromante', 'licántropo': 'Licántropo','licantropo': 'Licántropo','enredador': 'Enredador',
                    'troll': 'Troll Común', 'minotauro': 'Minotauro', 'momia': 'Momia', 'elfo oscuro': 'Elfo Oscuro',
                    'ettin': 'Ettin', 'espectro': 'Espectro', 'gárgola': 'Gárgola', 'wyvern': 'Wyvern',
                    'demonio': 'Demonio de Sangre', 'guardian': 'Guardián de la Tumba', 'psíquico': 'Psíquico',
                    'esfinge': 'Esfinge', 'naga': 'Naga', 'scorpion': 'Escorpión Gigante', 'vampiro': 'Vampiro',
                    'hidra': 'Hidra', 'gigante': 'Gigante', 'dragón': 'Dragón'
                };
                
                for (const [clave, valor] of Object.entries(palabrasClave)) {
                    if (nombreLimpio.includes(clave)) {
                        return this.monstruos_exp.monstruos.find(m => {
                            const nombresMonstruo = Array.isArray(m.nombre) ? m.nombre : [m.nombre];
                            return nombresMonstruo.includes(valor);
                        });
                    }
                }
                
                return null;
            }

            evaluarAccion(tipo_accion) {
                if (tipo_accion === "heroica") {
                    this.acciones_heroicas++;
                    this.actualizarEstados("heroica");
                } else {
                    this.acciones_deshonrosas++;
                    this.actualizarEstados("deshonrosa");
                }
                
                const tipo_reaccion = tipo_accion === "heroica" ? "apoyo" : "desprecio";
                const reacciones_publico = this.comportamiento.reacciones_publico || {};
                const reacciones = reacciones_publico[tipo_reaccion] || [];
                
                if (reacciones.length > 0) {
                    const reaccion = reacciones[Math.floor(Math.random() * reacciones.length)];
                    this.mostrarMensajeLog(`\nLos héroes realizan una acción ${tipo_accion}:`, tipo_accion);
                    this.mostrarMensajeLog(`» ${reaccion.efecto}`, reaccion.id > 15 ? 'critical' : 'efecto');
                    this.aplicarEfectoPublico(reaccion.id, tipo_accion === "heroica");
                }
                
                this.mostrarEstadosActuales();
            }
            
            actualizarEstados(tipo_accion) {
                const limites = this.estados_config.limites || {};
                const moral_max = limites.moral_max || 100;
                const cordura_max = limites.cordura_max || 100;
                
                const cambios = this.estados_config[tipo_accion] || {};
                
                if (cambios.moral) this.moral_grupo = Math.max(0, Math.min(moral_max, this.moral_grupo + cambios.moral));
                if (cambios.cordura) this.cordura = Math.max(0, Math.min(cordura_max, this.cordura + cambios.cordura));
                if (cambios.bonif_critico) {
                    this.bonif_critico = true;
                    this.mostrarMensajeLog("¡BONIFICACIÓN POR CRÍTICO ACTIVADA!", 'critical');
                }
                
                this.mostrarEstadosActuales();
            }
            
            mostrarEstadosActuales() {
                const limites = this.estados_config.limites || {};
                const moral_max = limites.moral_max || 100;
                const cordura_max = limites.cordura_max || 100;
                
                this.mostrarMensajeLog(`\nESTADO ACTUAL:`, 'titulo');
                this.mostrarMensajeLog(`Moral del Grupo: ${this.moral_grupo}/${moral_max}`, 'efecto');
                this.mostrarMensajeLog(`Cordura: ${this.cordura}/${cordura_max}`, 'efecto');
                if (this.bonif_critico) this.mostrarMensajeLog("¡BONUS CRÍTICO ACTIVO!", 'critical');
            }
            
            siguienteRonda() {
                
                if (this.ronda_actual >= 3) {
                    this.finalizarArena();
                    return;
                }
                
                document.getElementById('btn-heroico').disabled = false;
                document.getElementById('btn-deshonroso').disabled = false;
                this.ejecutarRonda(this.ronda_actual + 1);
            }
            
            finalizarArena() {
                this.mostrarMensajeLog("\n=== ¡LA ARENA HA CONCLUIDO! ===", 'titulo');
                const victoria = this.moral_grupo > 0 && this.cordura > 0;
                
                if (victoria) {
                    this.mostrarMensajeLog("¡VICTORIA DE LOS HÉROES!", 'heroico');
                    this.procesarRecompensas();
                } else {
                    this.mostrarMensajeLog("DERROTA...", 'deshonroso');
                    this.mostrarMensajeLog("Los héroes han caído en la arena", 'enemigo');
                }
                
                // RESTAURAR CONTROLES AL FINALIZAR (pero mantener iniciar deshabilitado hasta reinicio)
                document.getElementById('btn-ronda').disabled = true;
                document.getElementById('btn-heroico').disabled = true;
                document.getElementById('btn-deshonroso').disabled = true;
                document.getElementById('btn-iniciar').disabled = false; // Permitir nuevo inicio
                document.getElementById('btn-nivel-up').disabled = true; // Mantener bloqueados
                document.getElementById('btn-nivel-down').disabled = true;
                document.getElementById('btn-apuesta-up').disabled = true;
                document.getElementById('btn-apuesta-down').disabled = true;
                document.getElementById('select-arena').disabled = true;
                
                this.mostrarMensajeLog("\nPresiona 'Reiniciar' para comenzar una nueva arena", 'publico');
            }

            procesarRecompensas() {
                if (!this.recompensas || Object.keys(this.recompensas).length === 0) {
                    this.mostrarMensajeLog("No se encontraron recompensas configuradas", 'enemigo');
                    return;
                }
                
                let grupo_nivel = '';
                if (this.heroes_nivel <= 2) grupo_nivel = 'nivel_1_2';
                else if (this.heroes_nivel <= 4) grupo_nivel = 'nivel_3_4';
                else if (this.heroes_nivel <= 6) grupo_nivel = 'nivel_5_6';
                else if (this.heroes_nivel <= 8) grupo_nivel = 'nivel_7_8';
                else grupo_nivel = 'nivel_7_8';
                
                const recompensa = this.recompensas[grupo_nivel];
                
                if (!recompensa) {
                    this.mostrarMensajeLog(`No se encontraron recompensas para el grupo ${grupo_nivel}`, 'enemigo');
                    this.mostrarMensajeLog(`Recompensas disponibles: ${Object.keys(this.recompensas).join(', ')}`, 'enemigo');
                    return;
                }
                
                let monedas_base = recompensa.monedas || 0;
                let experiencia_base = (recompensa.experiencia || 0) + this.exp_total_acumulada;
                let tesoros = recompensa.tesoros || [];
                
                let multiplicador = 1.0;
                let ganancia_apuesta = 0;
                
                if (this.apuesta_activa && recompensa.multiplicador_monedas) {
                    multiplicador = recompensa.multiplicador_monedas;
                    ganancia_apuesta = parseInt(this.apuesta_monedas * multiplicador);
                }
                
                const monedas_final = monedas_base + ganancia_apuesta;
                const experiencia_final = experiencia_base;
                
                this.mostrarMensajeLog("\nRECOMPENSAS OBTENIDAS:", 'titulo');
                this.mostrarMensajeLog(`Nivel: ${recompensa.nivel}`, 'recompensa');
                this.mostrarMensajeLog(`${monedas_final} monedas de oro`, 'recompensa');
                this.mostrarMensajeLog(`${experiencia_final} puntos de experiencia`, 'recompensa');

                tesoros.forEach(tesoro => this.mostrarMensajeLog(`• ${tesoro}`, 'recompensa'));
                
                if (this.apuesta_activa) {
                    this.mostrarLogRecompensas(monedas_base, monedas_final, multiplicador, ganancia_apuesta, tesoros, experiencia_final, this.exp_total_acumulada);
                }
                
                this.procesarDescanso();
            }
           
            mostrarLogRecompensas(monedas_base, monedas_final, multiplicador, ganancia_apuesta, tesoros, experiencia_base, exp_monstruos) {
                this.mostrarMensajeLog("\nDESGLOSE DE RECOMPENSA:", 'titulo');
                this.mostrarMensajeLog(`Apuesta inicial: ${this.apuesta_monedas} monedas`, 'recompensa');
                this.mostrarMensajeLog(`Recompensa base: ${monedas_base} monedas`, 'recompensa');
                
                if (exp_monstruos > 0) {
                    this.mostrarMensajeLog(`Experiencia total de monstruos: +${this.exp_total_acumulada} EXP`, 'recompensa');
                    this.mostrarMensajeLog(`Experiencia base: +${experiencia_base - this.exp_total_acumulada} EXP`, 'recompensa');
                }
                
                this.mostrarMensajeLog(`Multiplicador: x${multiplicador}`, 'recompensa');
                this.mostrarMensajeLog(`Ganancia por apuesta: ${ganancia_apuesta} monedas`, 'recompensa');
                this.mostrarMensajeLog(`TOTAL: ${monedas_final} monedas y ${experiencia_base} EXP`, 'recompensa');
                
                tesoros.forEach(tesoro => this.mostrarMensajeLog(`• ${tesoro}`, 'recompensa'));
            }
            
            procesarDescanso() {
                const descanso = this.descansos["largo"];
                if (!descanso) {
                    this.mostrarMensajeLog("No se encontró información de descanso largo", 'enemigo');
                    return;
                }
                
                this.mostrarMensajeLog("\nDESCANSO EN LA TABERNA:", 'titulo');
                this.mostrarMensajeLog(descanso.descripcion || "Los héroes descansan y se recuperan", 'efecto');
                this.mostrarMensajeLog(`Duración: ${descanso.duracion}`, 'efecto');
                this.mostrarMensajeLog("\nBENEFICIOS:", 'titulo');
                
                if (descanso.beneficios && Array.isArray(descanso.beneficios)) {
                    descanso.beneficios.forEach(beneficio => this.mostrarMensajeLog(`• ${beneficio}`, 'lista'));
                }
                
                this.aplicarEfectosDescanso(descanso.efectos);
            }
            
            mostrarReglas() {
                const link = document.createElement('a');
                link.href = `${this.BASE_DIR}/assets/data/Arena_V1.4.pdf`;
                link.target = '_blank';
                link.download = 'Arena_V1.4.pdf';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                this.mostrarMensajeLog("\nAbriendo reglas de la arena...", 'publico');
            }
            
            aplicarEfectoPublico(id, esHeroico) {
                if (id > 15) {
                    if (esHeroico) this.moral_grupo = Math.min(this.estados_config.limites.moral_max, this.moral_grupo + 5);
                    else this.cordura = Math.max(0, this.cordura - 3);
                }
            }
            
            ocultarGrid() {
                document.getElementById('grid-container').classList.remove('visible');
                this.gridVisible = false;
            }
        }

        document.addEventListener('DOMContentLoaded', () => window.arenaApp = new ArenaApp());
    </script>
</body>
</html>