<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Tile Generator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #fff;
            background: url('images/interface/fondo_losetas.jpg') no-repeat center center fixed;
            background-size: cover;
            padding: 20px;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: -1;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(35, 35, 35, 0.1);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #8B4513;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 1px;
            border-bottom: 2px solid #8B4513;
        }

        .titulo-container {
            width: 90%;
            max-width: 2000px;
            height: 500px;
            margin: 0 auto 1px;
            background: url('images/interface/titulo_losetas.png') no-repeat center center;
            background-size: contain;
        }

        .subtitle {
            color: #d4af37;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px #000;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 40px;
            padding: 25px;
            background: rgba(60, 60, 60, 0.1);
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #5D4037;
        }

        .select-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 1px 1px 1px #000;
        }

        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #5D4037;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
            background: rgba(40, 40, 40, 0.9);
            color: #fff;
            background-image: url('images/interface/select_arrow.png');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 35px;
        }

        select:focus {
            border-color: #d4af37;
            outline: none;
        }

        .btn-container {
            display: flex;
            align-items: flex-end;
        }

        .btn {
            width: 360px;
            height: 120px;
            background: url('images/interface/btn_generar.png') no-repeat center center;
            background-size: contain;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px) scale(1.05);
            filter: brightness(1.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }

        .loseta-container {
            flex: 2;
            min-width: 100px;
            max-width: 1200px;
            min-height: 100px;
            max-height: 1200px;
            background: rgba(60, 60, 60, 0.1);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
            border: 1px solid #5D4037;
        }

        .loseta-title {
            text-align: center;
            margin-bottom: 15px;
            color: #d4af37;
            font-size: 1.4rem;
            text-shadow: 1px 1px 2px #000;
        }

        .matriz {
            display: grid;
            gap: 2px;
            background: transparent;
            padding: 8px;
            border-radius: 8px;
            /*min-height: 10px;*/
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            width: 100%;
        }

        .casilla {
            aspect-ratio: 1/1;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 3px;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            background-size: contain;
        }

        .casilla:hover {
            transform: scale(1.02);
            z-index: 1;
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 3px rgba(255, 215, 0, 0.5);
        }

        .casilla.invalida {
            background: rgba(0, 0, 0, 0.2);
            border: 1px dashed rgba(255, 255, 255, 0.2);
        }

        .casilla.ocupada {
            background: rgba(231, 76, 60, 0.3);
        }

        .enemigo {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            animation: aparecer 0.5s ease-out;
            z-index: 2;
            border: 2px solid rgba(0, 0, 0, 0.5);
            padding: 5px;
            box-sizing: border-box;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            object-fit: cover;
            overflow-y: hidden;
        }

        .enemigo.normal {
            border-radius: 8px;
            font-size: 14px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .enemigo.enorme {
            border-radius: 10px;
            font-size: 16px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .enemigo.extraenorme {
            border-radius: 12px;
            font-size: 18px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        @keyframes aparecer {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .info-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(60, 60, 60, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #5D4037;
        }

        .info-panel h3 {
            color: #d4af37;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #8B4513;
            text-align: center;
            text-shadow: 1px 1px 2px #000;
        }

        #enemigos-lista {
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .enemigo-item {
            padding: 12px;
            margin-bottom: 12px;
            background: rgba(40, 40, 40, 0.8);
            border-left: 5px solid #e74c3c;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
            color: #fff;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .enemigo-item:hover {
            transform: translateX(5px);
        }

        .enemigo-item strong {
            color: #d4af37;
            display: block;
            margin-bottom: 5px;
        }

        .tirada-info {
            background: rgba(52, 152, 219, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            color: #fff;
        }

        /* ESTILOS PARA EL CONTADOR DE VISITAS */
        .visitas-container {
            display: flex;
            justify-content: center;
            background: rgba(52, 73, 94, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            border: 1px solid #5D4037;
        }

        .visitas-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .visitas-value {
            font-size: 1.8rem;
            font-weight: bold;
            display: block;
            color: #d4af37;
        }

        .visitas-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        @media (max-width: 992px) {
            .visualization {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn-container {
                align-self: stretch;
            }
            
            .btn {
                width: 100%;
            }
        }

        footer {
            text-align: center;
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="titulo-container"></div>
            <p class="subtitle">Selecciona el nivel de héroes, tipo de enemigos y una loseta</p>
        </header>
        
        <div class="controls">
            <div class="select-group">
                <label for="nivel-heroes">Nivel de Héroes:</label>
                <select id="nivel-heroes">
                    <option value="">Selecciona nivel</option>
                    <option value="1">Nivel 1</option>
                    <option value="2">Nivel 2</option>
                    <option value="3">Nivel 3</option>
                    <option value="4">Nivel 4</option>
                    <option value="5">Nivel 5</option>
                    <option value="6">Nivel 6</option>
                    <option value="7">Nivel 7</option>
                    <option value="8">Nivel 8</option>
                    <option value="9">Nivel 9</option>
                    <option value="10">Nivel 10</option>
                </select>
            </div>
            
            <div class="select-group">
                <label for="tipo-enemigo">Tipo de Enemigos:</label>
                <select id="tipo-enemigo">
                    <option value="">Selecciona un tipo</option>
                </select>
            </div>
            
            <div class="select-group">
                <label for="loseta">Loseta:</label>
                <select id="loseta">
                    <option value="">Selecciona una loseta</option>
                </select>
            </div>
            
            <div class="btn-container">
                <button id="generar-btn" class="btn"></button>
            </div>
        </div>
        
        <div class="visualization">
            <div class="loseta-container">
                <h3 class="loseta-title" id="loseta-title">Selecciona una loseta</h3>
                <div id="matriz-loseta" class="matriz"></div>
            </div>
            
            <div class="info-panel">
                <h3>Enemigos Generados</h3>
                <div id="tirada-info" class="tirada-info" style="display: none;">
                    <strong>Información de la tirada:</strong><br>
                    <span id="tirada-detalle"></span>
                </div>
                <div id="enemigos-lista"></div>
            </div>
        </div>
        
        <!-- CONTADOR DE VISITAS (reemplaza la sección de estadísticas) -->
        <div class="visitas-container">
            <div class="visitas-item">
                <span class="visitas-value" id="contador-visitas">0</span>
                <span class="visitas-label">Visitas a esta página</span>
            </div>
        </div>
        
        <footer>
            <p>Proyecto de Visualización de Enemigos &copy; 2023</p>
        </footer>
    </div>

    <script>
        // Variables globales
        let enemigosData = {};
        let losetasData = {};
        let tamanosMonstruos = {};
        let monstruosImagenes = {}; // Nueva variable para almacenar las imágenes
        let enemigosCargados = [];
        let losetaSeleccionada = null;
        let nivelHeroes = 0;
        const isGitHubPages = window.location.hostname.includes('github.io');

        // Cargar datos iniciales
        document.addEventListener('DOMContentLoaded', async () => {
            await cargarTamanosMonstruos();
            await cargarMonstruosImagenes(); // Nueva función para cargar imágenes
            cargarTiposEnemigos();
            cargarLosetas();
            
            // Inicializar contador de visitas
            actualizarContadorVisitas();
            
            document.getElementById('nivel-heroes').addEventListener('change', (e) => {
                nivelHeroes = parseInt(e.target.value) || 0;
            });
            
            document.getElementById('generar-btn').addEventListener('click', generarEnemigos);
        });

        // Función para actualizar el contador de visitas
        function actualizarContadorVisitas() {
            let visitas = localStorage.getItem('visitasPagina');
            
            if (visitas) {
                visitas = parseInt(visitas) + 1;
            } else {
                visitas = 1;
            }
            
            localStorage.setItem('visitasPagina', visitas);
            document.getElementById('contador-visitas').textContent = visitas;
        }

        // Función para cargar las imágenes de monstruos
        async function cargarMonstruosImagenes() {
            try {
                const ruta = isGitHubPages ? 'data/monstruos-imagenes.json' : 'data\\monstruos-imagenes.json';
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar monstruos-imagenes.json: ${response.status}`);
                }
                
                monstruosImagenes = await response.json();
                console.log('Imágenes de monstruos cargadas:', monstruosImagenes);
            } catch (error) {
                console.error('Error cargando imágenes de monstruos:', error);
                // Inicializar objeto vacío si hay error
                monstruosImagenes = { mapeo_imagenes: {}, plurales: {} };
            }
        }
    
       
        function obtenerImagenToken(nombre) {
            console.log("=== BÚSQUEDA DE IMAGEN PARA:", nombre, "===");
            
            if (!monstruosImagenes.mapeo_imagenes) {
                console.warn("mapeo_imagenes no está definido");
                return 'images/tokens/default.png';
            }
            
            // Normalizar el nombre: minúsculas, sin acentos, sin caracteres especiales
            let nombreLimpio = nombre.toLowerCase().trim()
                .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                .replace(/[^\w\s]/gi, '');
            
            console.log("Nombre limpio inicial:", nombreLimpio);
            
            // Eliminar expresiones de dados y multiplicadores
            nombreLimpio = nombreLimpio.replace(/^\d+d\d+\+\d+(\s+|$)/, '');
            nombreLimpio = nombreLimpio.replace(/^\d+d\d+(\s+|$)/, '');
            nombreLimpio = nombreLimpio.replace(/^\d+x(\s+|$)/, '');
            nombreLimpio = nombreLimpio.replace(/^\d+(\s+|$)/, '');
            
            console.log("Después de quitar dados/multiplicadores:", nombreLimpio);
            
            // 1. PRIMERO: Buscar nombres compuestos (más específicos primero)
            const nombresCompuestos = Object.keys(monstruosImagenes.mapeo_imagenes)
                .filter(clave => clave.includes(' ') && nombreLimpio.includes(clave))
                .sort((a, b) => b.length - a.length); // Los más largos primero
            
            if (nombresCompuestos.length > 0) {
                console.log("Nombres compuestos encontrados:", nombresCompuestos);
                const mejorCoincidencia = nombresCompuestos[0];
                console.log("✅ Coincidencia COMPUESTA encontrada:", mejorCoincidencia);
                return `images/tokens/${monstruosImagenes.mapeo_imagenes[mejorCoincidencia]}`;
            }
            
            // 2. Buscar en plurales
            if (monstruosImagenes.plurales) {
                for (const [plural, singular] of Object.entries(monstruosImagenes.plurales)) {
                    const pluralLimpio = plural.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                    if (nombreLimpio === pluralLimpio) {
                        nombreLimpio = singular.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                        console.log("Convertido a singular:", nombreLimpio);
                        break;
                    }
                }
            }
            
            // Reglas generales de singularización
            if (nombreLimpio.endsWith('es')) {
                nombreLimpio = nombreLimpio.slice(0, -2);
                console.log("Removido 'es':", nombreLimpio);
            } else if (nombreLimpio.endsWith('s')) {
                nombreLimpio = nombreLimpio.slice(0, -1);
                console.log("Removido 's':", nombreLimpio);
            }
            
            console.log("Nombre final para búsqueda:", nombreLimpio);
            
            // 3. Buscar coincidencia EXACTA
            if (monstruosImagenes.mapeo_imagenes[nombreLimpio]) {
                console.log("✅ Coincidencia EXACTA encontrada:", nombreLimpio);
                return `images/tokens/${monstruosImagenes.mapeo_imagenes[nombreLimpio]}`;
            }
            
            console.log("❌ No hay coincidencia exacta. Buscando parcial...");
            
            // 4. Buscar coincidencia PARCIAL con PRIORIDAD de coincidencia más larga
            const clavesOrdenadas = Object.keys(monstruosImagenes.mapeo_imagenes)
                .sort((a, b) => b.length - a.length); // Ordenar de más largo a más corto
            
            for (const clave of clavesOrdenadas) {
                const claveLimpia = clave.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                if (nombreLimpio.includes(claveLimpia)) {
                    console.log("✅ Coincidencia PARCIAL encontrada:", clave, "en", nombreLimpio);
                    return `images/tokens/${monstruosImagenes.mapeo_imagenes[clave]}`;
                }
            }
            
            // 5. Imagen por defecto
            console.warn("❌❌❌ NO se encontró imagen para:", nombre);
            console.log("Claves disponibles:", Object.keys(monstruosImagenes.mapeo_imagenes));
            return 'images/tokens/default.png';
        }
        

        // Cargar tamaños de monstruos
        async function cargarTamanosMonstruos() {
            try {
                const ruta = isGitHubPages ? 'data/tamanos_monstruos.json' : 'data\\tamanos_monstruos.json';
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar tamanos_monstruos.json: ${response.status}`);
                }
                
                const data = await response.json();
                tamanosMonstruos = data.tamaños;
                console.log('Tamaños de monstruos cargados:', tamanosMonstruos);
            } catch (error) {
                console.error('Error cargando tamaños de monstruos:', error);
                alert('Error al cargar los tamaños de monstruos.');
            }
        }
        
        
           
        function obtenerTamanoMonstruo(nombre) {
            let nombreNormalizado = nombre.trim();
            console.log("Obteniendo tamaño para:", nombreNormalizado);
            
            // 1. PRIMERO buscar coincidencia EXACTA (case-sensitive)
            if (tamanosMonstruos[nombreNormalizado]) {
                console.log("Tamaño encontrado (exacto):", tamanosMonstruos[nombreNormalizado]);
                return tamanosMonstruos[nombreNormalizado];
            }
            
            // 2. Buscar coincidencia exacta sin sensibilidad a mayúsculas
            const claves = Object.keys(tamanosMonstruos);
            for (const clave of claves) {
                if (clave.toLowerCase() === nombreNormalizado.toLowerCase()) {
                    console.log("Tamaño encontrado (exacto case-insensitive):", tamanosMonstruos[clave]);
                    return tamanosMonstruos[clave];
                }
            }
            
            // 3. Buscar coincidencia exacta singularizada
            if (nombreNormalizado.endsWith('s') && nombreNormalizado.length > 5) {
                const singular = nombreNormalizado.slice(0, -1);
                if (tamanosMonstruos[singular]) {
                    console.log("Tamaño encontrado (singularizado):", tamanosMonstruos[singular]);
                    return tamanosMonstruos[singular];
                }
                
                // También probar sin sensibilidad a mayúsculas
                for (const clave of claves) {
                    if (clave.toLowerCase() === singular.toLowerCase()) {
                        console.log("Tamaño encontrado (singularizado case-insensitive):", tamanosMonstruos[clave]);
                        return tamanosMonstruos[clave];
                    }
                }
            }
            
            // 4. SOLO AHORA buscar coincidencias PARCIALES con PRIORIDAD de coincidencia más larga
            let mejorCoincidencia = null;
            let longitudMejorCoincidencia = 0;
            
            // Ordenar claves de más larga a más corta para priorizar coincidencias específicas
            const clavesOrdenadas = Object.keys(tamanosMonstruos).sort((a, b) => b.length - a.length);
            
            for (const key of clavesOrdenadas) {
                // Buscar si el nombre contiene la clave completa (coincidencia parcial)
                if (nombreNormalizado.toLowerCase().includes(key.toLowerCase())) {
                    // Priorizar la coincidencia MÁS LARGA
                    if (key.length > longitudMejorCoincidencia) {
                        mejorCoincidencia = key;
                        longitudMejorCoincidencia = key.length;
                    }
                }
            }
            
            if (mejorCoincidencia) {
                console.log("Tamaño encontrado (parcial):", tamanosMonstruos[mejorCoincidencia]);
                return tamanosMonstruos[mejorCoincidencia];
            }
            
            // 5. Valor por defecto
            console.log("Tamaño por defecto: NORMAL");
            return "NORMAL";
        }


        // Cargar tipos de enemigos disponibles
        async function cargarTiposEnemigos() {
            try {
                // Lista de tipos de enemigos disponibles
                const tipos = ['bandidos', 'bestias', 'elfos_oscuros', 'no_muertos', 'orcos_goblins', 'reptiles', 'tierras_antiguas'];
                const select = document.getElementById('tipo-enemigo');
                
                // Limpiar opciones existentes (excepto la primera)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Añadir opciones
                tipos.forEach(tipo => {
                    const option = document.createElement('option');
                    option.value = tipo;
                    option.textContent = tipo.charAt(0).toUpperCase() + tipo.slice(1).replace(/_/g, ' ');
                    select.appendChild(option);
                });
                
                select.addEventListener('change', async (e) => {
                    if (e.target.value) {
                        await cargarEnemigos(e.target.value);
                    }
                });
            } catch (error) {
                console.error('Error cargando tipos de enemigos:', error);
            }
        }

        // Cargar enemigos desde JSON
        async function cargarEnemigos(tipo) {
            try {
                const ruta = isGitHubPages ? `data/${tipo}.json` : `data\\${tipo}.json`;
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar ${tipo}.json: ${response.status}`);
                }
                enemigosData = await response.json();
                console.log(`Enemigos de tipo ${tipo} cargados:`, enemigosData);
            } catch (error) {
                console.error('Error cargando enemigos:', error);
                alert(`Error al cargar los datos de ${tipo}.`);
            }
        }

        // Cargar losetas disponibles
        async function cargarLosetas() {
            try {
                const ruta = isGitHubPages ? 'data/losetas.json' : 'data\\losetas.json';
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar losetas.json: ${response.status}`);
                }
        
                const data = await response.json();
                losetasData = data.losetas;
                
                // Ordenar losetas alfabéticamente por nombre
                losetasData.sort((a, b) => a.nombre.localeCompare(b.nombre));
                
                const select = document.getElementById('loseta');
                
                // Limpiar opciones existentes (excepto la primera)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Añadir opciones
                losetasData.forEach(loseta => {
                    const option = document.createElement('option');
                    option.value = loseta.nombre;
                    option.textContent = loseta.nombre;
                    select.appendChild(option);
                });
                
                select.addEventListener('change', async (e) => {
                    if (e.target.value) {
                        await cargarLoseta(e.target.value);
                    }
                });
            } catch (error) {
                console.error('Error cargando losetas:', error);
                alert('Error al cargar las losetas.');
            }
        }

        // Cargar loseta específica
        async function cargarLoseta(nombre) {
            try {
                // Buscar la loseta por nombre
                const loseta = losetasData.find(l => l.nombre === nombre);
                if (!loseta) {
                    throw new Error(`Loseta ${nombre} no encontrada`);
                }
                
                losetaSeleccionada = loseta;
                document.getElementById('loseta-title').textContent = losetaSeleccionada.nombre;
                visualizarLoseta(losetaSeleccionada);
                console.log(`Loseta ${nombre} cargada:`, losetaSeleccionada);
            } catch (error) {
                console.error('Error cargando loseta:', error);
                alert(`Error al cargar la loseta ${nombre}.`);
            }
        }

        // Visualizar la loseta con su matriz
        function visualizarLoseta(loseta) {
            const matrizContainer = document.getElementById('matriz-loseta');
            matrizContainer.innerHTML = '';
            
            const rutaImagen = isGitHubPages ? 
                `images/losetas/${loseta.imagen}.png` : 
                `images/losetas/${loseta.imagen}.png`;
            
            // Crear una imagen para precargarla y verificar si existe
            const img = new Image();
            img.onload = function() {
                matrizContainer.style.backgroundImage = `url(${rutaImagen})`;
                matrizContainer.style.backgroundSize = 'contain';
                matrizContainer.style.backgroundRepeat = 'no-repeat'
            };
            img.onerror = function() {
                console.warn(`No se pudo cargar la imagen: ${rutaImagen}`);
                matrizContainer.style.backgroundImage = 'none';
            };
            img.src = rutaImagen;
            
            // Determinar dimensiones de la matriz
            const filas = loseta.matriz.length;
            const columnas = loseta.matriz[0].length;
            
            // Actualizar la cuadrícula CSS para que coincida con las dimensiones de la loseta
            matrizContainer.style.gridTemplateColumns = `repeat(${columnas}, 1fr)`;
            matrizContainer.style.gridTemplateRows = `repeat(${filas}, 1fr)`;
            
            // Crear casillas
            for (let i = 0; i < filas; i++) {
                for (let j = 0; j < columnas; j++) {
                    const casilla = document.createElement('div');
                    casilla.className = 'casilla';
                    casilla.dataset.fila = i;
                    casilla.dataset.columna = j;
                    
                    if (loseta.matriz[i][j] === 0) {
                        casilla.classList.add('invalida');
                    }
                    
                    matrizContainer.appendChild(casilla);
                }
            }
        }

        // Realizar tirada de dado de 20 caras
        function tirarD20() {
            return Math.floor(Math.random() * 20) + 1;
        }

        // Calcular tirada según nivel de héroes
        function calcularTirada() {
            if (nivelHeroes < 1) return 0;
            
            const tiradaDado = tirarD20();
            const modificador = (nivelHeroes - 1) * 10;
            const tiradaFinal = tiradaDado + modificador;
            
            return {
                dado: tiradaDado,
                modificador: modificador,
                total: tiradaFinal
            };
        }

        // Encontrar encuentro según tirada
        function encontrarEncuentroPorTirada(tirada) {
            if (!enemigosData.encuentros) return null;
            
            for (const encuentro of enemigosData.encuentros) {
                const [min, max] = encuentro.tirada.split('-').map(Number);
                if (tirada >= min && tirada <= max) {
                    return encuentro;
                }
            }
            
            // Si no encuentra ningún encuentro, devolver el último
            return enemigosData.encuentros[enemigosData.encuentros.length - 1];
        }

        // Obtener dimensiones según el tipo de enemigo
        function obtenerDimensionesEnemigo(tamano) {
            switch (tamano) {
                case 'ENORME': 
                    return { ancho: 2, alto: 2, casillas: 4 };
                case 'EXTRAENORME': 
                    return { ancho: 3, alto: 2, casillas: 6 };
                default: 
                    return { ancho: 1, alto: 1, casillas: 1 };
            }
        }

        // Verificar si un área está disponible para colocar un enemigo
        function areaDisponible(filaInicio, columnaInicio, tamano) {
            const dimensiones = obtenerDimensionesEnemigo(tamano);
            const ancho = dimensiones.ancho;
            const alto = dimensiones.alto;
            
            for (let i = 0; i < alto; i++) {
                for (let j = 0; j < ancho; j++) {
                    const fila = filaInicio + i;
                    const columna = columnaInicio + j;
                    
                    // Verificar si está dentro de los límites
                    if (fila >= losetaSeleccionada.matriz.length || columna >= losetaSeleccionada.matriz[0].length) {
                        return false;
                    }
                    
                    const casilla = document.querySelector(`.casilla[data-fila="${fila}"][data-columna="${columna}"]`);
                    
                    if (!casilla || 
                        casilla.classList.contains('invalida') || 
                        casilla.classList.contains('ocupada')) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // Marcar área como ocupada
        function marcarAreaOcupada(filaInicio, columnaInicio, tamano) {
            const dimensiones = obtenerDimensionesEnemigo(tamano);
            const ancho = dimensiones.ancho;
            const alto = dimensiones.alto;
            
            for (let i = 0; i < alto; i++) {
                for (let j = 0; j < ancho; j++) {
                    const fila = filaInicio + i;
                    const columna = columnaInicio + j;
                    
                    const casilla = document.querySelector(`.casilla[data-fila="${fila}"][data-columna="${columna}"]`);
                    if (casilla) {
                        casilla.classList.add('ocupada');
                    }
                }
            }
        }

        // Función mejorada para procesar expresiones de dados
        function procesarExpresionDados(expresion) {
            let cantidad = 0;
            
            // Patrones para diferentes tipos de expresiones
            const patrones = [
                // Patrón para "1d4+1" o "2d6+3"
                /(\d+)d(\d+)\+(\d+)/,
                // Patrón para "1d4" o "2d6"  
                /(\d+)d(\d+)/,
                // Patrón para números simples "3" or "12"
                /(\d+)/
            ];
            
            for (const patron of patrones) {
                const match = expresion.match(patron);
                if (match) {
                    if (match[3]) {
                        // Formato: XdY+Z
                        const numDados = parseInt(match[1]);
                        const carasDado = parseInt(match[2]);
                        const bonus = parseInt(match[3]);
                        
                        for (let i = 0; i < numDados; i++) {
                            cantidad += Math.floor(Math.random() * carasDado) + 1;
                        }
                        cantidad += bonus;
                    } else if (match[2]) {
                        // Formato: XdY
                        const numDados = parseInt(match[1]);
                        const carasDado = parseInt(match[2]);
                        
                        for (let i = 0; i < numDados; i++) {
                            cantidad += Math.floor(Math.random() * carasDado) + 1;
                        }
                    } else {
                        // Formato: número simple
                        cantidad = parseInt(match[1]);
                    }
                    break;
                }
            }
            
            return cantidad;
        }

        // Función mejorada para procesar descripción de encuentro
function procesarDescripcionEncuentro(descripcion) {
    const enemigos = [];
    
    console.log("Procesando descripción:", descripcion);
    
    // Primero, buscar nombres compuestos conocidos (prioridad máxima)
    const nombresCompuestos = Object.keys(tamanosMonstruos).filter(nombre => 
        nombre.includes(" ") && descripcion.includes(nombre)
    ).sort((a, b) => b.length - a.length); // Ordenar de más largo a más corto
    
    // Si encontramos nombres compuestos, procesarlos primero
    if (nombresCompuestos.length > 0) {
        console.log("Nombres compuestos encontrados:", nombresCompuestos);
        
        let descripcionRestante = descripcion;
        for (const nombreCompuesto of nombresCompuestos) {
            if (descripcionRestante.includes(nombreCompuesto)) {
                // Crear patrón para buscar la cantidad antes del nombre
                const patron = new RegExp(`(\\d+d\\d+\\+\\d+|\\d+d\\d+|\\d+)\\s*${nombreCompuesto.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, "i");
                const match = descripcionRestante.match(patron);
                
                if (match) {
                    const expresion = match[1];
                    const cantidad = procesarExpresionDados(expresion);
                    const tamano = obtenerTamanoMonstruo(nombreCompuesto);
                    
                    console.log("Nombre compuesto procesado:", nombreCompuesto, "Cantidad:", cantidad);
                    
                    // Extraer descripción con "con" si existe
                    let descripcionCon = "";
                    const indiceCon = descripcionRestante.indexOf(" con ");
                    if (indiceCon > -1) {
                        descripcionCon = descripcionRestante.substring(indiceCon + 5);
                        // Limpiar descripción (quitar lo que viene después de "y" o "Armadura")
                        descripcionCon = descripcionCon.split(/\s+y\s+|Armadura/)[0].trim();
                        console.log("Descripción con 'con':", descripcionCon);
                    }
                    
                    for (let i = 0; i < cantidad; i++) {
                        enemigos.push({
                            nombre: nombreCompuesto,
                            descripcionCompleta: descripcionRestante.trim(),
                            descripcionCon: descripcionCon,
                            nivel: nivelHeroes,
                            tamano: tamano
                        });
                    }
                    
                    // Eliminar esta parte procesada de la descripción restante
                    descripcionRestante = descripcionRestante.replace(match[0], "").trim();
                }
            }
        }
        
        // Si procesamos toda la descripción con nombres compuestos, retornar
        if (descripcionRestante.replace(/[\s,;y]+/g, '').length === 0) {
            console.log("Enemigos procesados (solo nombres compuestos):", enemigos);
            return enemigos;
        }
        
        // Continuar con el procesamiento normal para el resto
        descripcion = descripcionRestante;
    }
    
    // Dividir la descripción en partes usando "y" como separador principal
    const partesPrincipales = descripcion.split(/(?:\s+y\s+)/i);
    
    for (const partePrincipal of partesPrincipales) {
        if (!partePrincipal.trim()) continue;
        
        console.log("Procesando parte:", partePrincipal);
        
        // Extraer descripción con "con" si existe
        let descripcionCon = "";
        let parteSinCon = partePrincipal;
        const indiceCon = partePrincipal.toLowerCase().indexOf(" con ");
        if (indiceCon > -1) {
            descripcionCon = partePrincipal.substring(indiceCon + 5);
            // Limpiar descripción (quitar lo que viene después de "y" o "Armadura")
            descripcionCon = descripcionCon.split(/\s+y\s+|Armadura/i)[0].trim();
            parteSinCon = partePrincipal.substring(0, indiceCon);
            console.log("Descripción con 'con':", descripcionCon);
        }
        
        // MEJORADO: Patrón que captura mejor nombres complejos
        // Ahora también excluye palabras de equipamiento comunes
        const patronDadosGlobal = /(\d+d\d+\+\d+|\d+d\d+|\d+)\s*([^0-9()]+?)(?=\s*(?:\d+d\d+\+\d+|\d+d\d+|\d+|\s+y\s+|Armadura\s*\d*|con\s+[^0-9]|$))/gi;
        
        let match;
        let encontrado = false;
        
        while ((match = patronDadosGlobal.exec(parteSinCon)) !== null) {
            encontrado = true;
            const expresion = match[1];
            let nombreEnemigo = match[2].trim();
            
            console.log("Expresión:", expresion, "Nombre:", nombreEnemigo);
            
            // Limpiar posibles conectores al final
            nombreEnemigo = nombreEnemigo.replace(/\s*(?:,|;|y|con|Armadura\s*\d*|$)\s*$/i, '');
            
            // Caso especial para "Hombres Bestia" - convertirlo a singular
            if (nombreEnemigo.includes("Hombres Bestia")) {
                nombreEnemigo = nombreEnemigo.replace("Hombres Bestia", "Hombre Bestia");
            }
            
            // Verificar si el nombre contiene palabras de equipamiento comunes
            const palabrasEquipamiento = ["espada", "hacha", "arco", "daga", "escudo", "lanza", "jabalina", "mayal", "bastón", "red", "ballesta", "alabarda", "maza", "martillo", "lucero"];
            const tieneEquipamiento = palabrasEquipamiento.some(palabra => 
                nombreEnemigo.toLowerCase().includes(palabra) && !tamanosMonstruos[nombreEnemigo]
            );
            
            if (tieneEquipamiento) {
                console.log("Posible equipamiento detectado, omitiendo:", nombreEnemigo);
                continue;
            }
            
            if (nombreEnemigo && nombreEnemigo.length > 1) {
                const cantidad = procesarExpresionDados(expresion);
                const tamano = obtenerTamanoMonstruo(nombreEnemigo);
                
                console.log("Cantidad:", cantidad, "Tamaño:", tamano, "Para:", nombreEnemigo);
                
                // Añadir cada enemigo individualmente con el tamaño correcto
                for (let i = 0; i < cantidad; i++) {
                    enemigos.push({
                        nombre: nombreEnemigo,
                        descripcionCompleta: partePrincipal.trim(),
                        descripcionCon: descripcionCon,
                        nivel: nivelHeroes,
                        tamano: tamano
                    });
                }
            }
        }
        
        // Si no encontramos patrones de dados pero la parte es significativa
        if (!encontrado && parteSinCon.trim().length > 2) {
            // Buscar si hay un número simple al inicio
            const matchNumeroSimple = parteSinCon.match(/^(\d+)\s+([^0-9]+?)(?=\s*(?:Armadura\s*\d*|con\s+[^0-9]|$))/i);
            if (matchNumeroSimple) {
                const cantidad = parseInt(matchNumeroSimple[1]);
                let nombreEnemigo = matchNumeroSimple[2].trim();
                const tamano = obtenerTamanoMonstruo(nombreEnemigo);
                
                console.log("Coincidencia simple - Cantidad:", cantidad, "Nombre:", nombreEnemigo);
                
                // Caso especial para "Hombres Bestia"
                if (nombreEnemigo.includes("Hombres Bestia")) {
                    nombreEnemigo = nombreEnemigo.replace("Hombres Bestia", "Hombre Bestia");
                }
                
                // Verificar si el nombre contiene palabras de equipamiento
                const palabrasEquipamiento = ["espada", "hacha", "arco", "daga", "escudo", "lanza", "jabalina", "mayal", "bastón", "red", "ballesta", "alabarda", "maza", "martillo", "lucero"];
                const tieneEquipamiento = palabrasEquipamiento.some(palabra => 
                    nombreEnemigo.toLowerCase().includes(palabra) && !tamanosMonstruos[nombreEnemigo]
                );
                
                if (tieneEquipamiento) {
                    console.log("Posible equipamiento detectado, omitiendo:", nombreEnemigo);
                    continue;
                }
                
                // Limpiar conectores al final
                nombreEnemigo = nombreEnemigo.replace(/\s*(?:,|;|y|con|Armadura\s*\d*|$)\s*$/i, '');
                
                for (let i = 0; i < cantidad; i++) {
                    enemigos.push({
                        nombre: nombreEnemigo,
                        descripcionCompleta: partePrincipal.trim(),
                        descripcionCon: descripcionCon,
                        nivel: nivelHeroes,
                        tamano: tamano
                    });
                }
            } else {
                // Si no hay número, asumir 1 enemigo
                let nombreEnemigo = parteSinCon.trim();
                const tamano = obtenerTamanoMonstruo(nombreEnemigo);
                
                // Caso especial para "Hombres Bestia"
                if (nombreEnemigo.includes("Hombres Bestia")) {
                    nombreEnemigo = nombreEnemigo.replace("Hombres Bestia", "Hombre Bestia");
                }
                
                // Verificar si el nombre contiene palabras de equipamiento
                const palabrasEquipamiento = [
                    // Armas cuerpo a cuerpo
                    "espada", "hacha", "daga", "lanza", "mayal", "maza", "martillo", "alabarda", 
                    "bastón", "baculo", "báculo", "puñal", "cuchillo", "mandoble", "espadón", 
                    "gladius", "sable", "estoque", "alfanje", "cimitarra", "montante", "brandistock",
                    "hachuela", "hachón", "guja", "bisarma", "tridente", "lanceta", "pica", "chuzo",
                    "azagaya", "venablo", "jabalina", "agarre", "garrote", "porra", "mangual", 
                    "nunchaku", "tonfa", "macana", "clava", "morrión", "montante", "verduguillo",
                    
                    // Armas a distancia
                    "arco", "ballesta", "honda", "cerbatana", "propulsor", "dardo", "flecha", 
                    "virote", "saeta", "proyectil", "carcaj", "carcax", "tirachinas", "funda",
                    
                    // Escudos y protecciones
                    "escudo", "rodela", "adarga", "broquel", "pavés", "tarja", "rondela", 
                    "cetro", "tablachina", "defensa", "protección", "armadura", "yelmo", 
                    "casco", "coraza", "peto", "greba", "brazal", "guardabrazo", "cubremuñeca",
                    "hombrera", "muslera", "guardapiernas", "cotilla", "sobreveste", "cota",
                    "malla", "loriga", "lorigón", "perneras", "guardarrenes", "escarcela",
                    
                    // Equipamiento diverso
                    "red", "lazo", "bozal", "rienda", "freno", "estribo", "silla", "montura",
                    "antorcha", "lámpara", "candil", "farol", "luminaria", "luz", "antorcha",
                    "cuerda", "soga", "cadena", "grillete", "cepo", "trampa", "cebo", "señuelo",
                    "gancho", "garfio", "arpón", "anzuelo", "cuchara", "tenaza", "alicate",
                    
                    // Objetos mágicos y especiales
                    "varita", "varón", "orbe", "amuleto", "talismán", "medallón", "gema",
                    "piedra", "cristal", "pergamino", "libro", "grimorio", "tomo", "códice",
                    "poción", "elixir", "ungüento", "bálsamo", "brebaje", "infusión", "esencia",
                    
                    // Materiales y tipos
                    "corto", "largo", "ancha", "ancho", "curvo", "recto", "pesado", "ligero",
                    "grande", "pequeño", "afilado", "mocho", "roto", "nuevo", "viejo", "usado",
                    "maldito", "bendito", "encantado", "mágico", "runico", "sagrado", "profano",
                    "demoníaco", "angelical", "dracónico", "élfico", "enano", "orco", "goblin",
                    
                    // Términos específicos de D&D/RPG
                    "lucero", "del", "alba", "macedonia", "estelar", "abyssalis", "caótico",
                    "ordenado", "neutral", "siniestro", "luminoso", "sombrío", "oscuro", "umbrio",
                    "solar", "lunar", "estelar", "cósmico", "terrenal", "celestial", "infernal",
                    "abismal", "primordial", "arcano", "divino", "profético", "oracular",
                    
                    // Términos adicionales en español
                    "corvo", "machete", "facón", "chafarote", "terciado", "jineta", "ropera",
                    "florete", "sable", "alfanje", "cimitarra", "shamshir", "talwar", "scimitar",
                    "falchion", "falcatra", "khopesh", "shotel", "kriss", "kukri", "katana",
                    "wakizashi", "tachi", "nodachi", "naginata", "nagamaki", "nagamaki", "yari",
                    "nagamaki", "nagamaki", "nagamaki", "nagamaki", "nagamaki", "nagamaki"
                ];
                const tieneEquipamiento = palabrasEquipamiento.some(palabra => 
                    nombreEnemigo.toLowerCase().includes(palabra) && !tamanosMonstruos[nombreEnemigo]
                );
                
                if (tieneEquipamiento) {
                    console.log("Posible equipamiento detectado, omitiendo:", nombreEnemigo);
                    continue;
                }
                
                // Limpiar "Armadura X" y otros conectores del final
                nombreEnemigo = nombreEnemigo.replace(/\s*(?:Armadura\s*\d*|con\s+[^0-9]|,|;|y|$)\s*$/i, '');
                
                enemigos.push({
                    nombre: nombreEnemigo,
                    descripcionCompleta: partePrincipal.trim(),
                    descripcionCon: descripcionCon,
                    nivel: nivelHeroes,
                    tamano: tamano
                });
            }
        }
    }
    
    console.log("Enemigos procesados:", enemigos);
    return enemigos;    
}

       



        // Función principal para generar enemigos
        function generarEnemigos() {
            // Validaciones
            if (nivelHeroes < 1) {
                alert('Por favor, selecciona un nivel de héroes.');
                return;
            }
            
            if (!enemigosData.encuentros) {
                alert('Por favor, selecciona un tipo de enemigos.');
                return;
            }
            
            if (!losetaSeleccionada) {
                alert('Por favor, selecciona una loseta.');
                return;
            }
            
            // Limpiar enemigos anteriores
            limpiarEnemigosAnteriores();
            
            // Calcular tirada
            const tirada = calcularTirada();
            
            // Encontrar encuentro
            const encuentro = encontrarEncuentroPorTirada(tirada.total);
            
            if (!encuentro) {
                alert('No se encontró un encuentro para la tirada ' + tirada.total);
                return;
            }
            
            // Mostrar información de la tirada
            document.getElementById('tirada-info').style.display = 'block';
            document.getElementById('tirada-detalle').textContent = 
                `Dado: ${tirada.dado} + Modificador (Nivel ${nivelHeroes}): ${tirada.modificador} = Total: ${tirada.total}`;
            
            // Procesar descripción del encuentro
            enemigosCargados = procesarDescripcionEncuentro(encuentro.descripcion);
            
            // Mostrar enemigos en la lista
            mostrarEnemigosLista(enemigosCargados);
            
            // Colocar enemigos en la loseta
            colocarEnemigosEnLoseta(enemigosCargados);
        }

        // Limpiar enemigos anteriores
        function limpiarEnemigosAnteriores() {
            // Remover elementos enemigo del DOM
            document.querySelectorAll('.enemigo').forEach(el => el.remove());
            
            // Limpiar clases ocupadas
            document.querySelectorAll('.casilla.ocupada').forEach(el => {
                el.classList.remove('ocupada');
            });
            
            // Limpiar lista de enemigos
            document.getElementById('enemigos-lista').innerHTML = '';
            enemigosCargados = [];
        }

        

        // Mostrar enemigos en la lista
        function mostrarEnemigosLista(enemigos) {
            const lista = document.getElementById('enemigos-lista');
            lista.innerHTML = '';
            
            // Agrupar enemigos por tipo para mostrar más limpio
            const enemigosAgrupados = {};
            
            enemigos.forEach(enemigo => {
                const clave = enemigo.nombre + (enemigo.descripcionCon ? "|" + enemigo.descripcionCon : "");
                if (!enemigosAgrupados[clave]) {
                    enemigosAgrupados[clave] = {
                        cantidad: 0,
                        tamano: enemigo.tamano,
                        descripcion: enemigo.descripcionCompleta,
                        descripcionCon: enemigo.descripcionCon
                    };
                }
                enemigosAgrupados[clave].cantidad++;
            });
            
            // Crear elementos para cada tipo de enemigo
            for (const [clave, info] of Object.entries(enemigosAgrupados)) {
                const [nombre, descripcionCon] = clave.split("|");
                const item = document.createElement('div');
                item.className = 'enemigo-item';
                
                let contenido = `<strong>${info.cantidad}x ${nombre}</strong>
                                <div>Tamaño: ${info.tamano}</div>
                                <div>Nivel: ${nivelHeroes}</div>`;
                
                if (info.descripcionCon) {
                    contenido += `<div>Equipamiento: ${info.descripcionCon}</div>`;
                }
                
                item.innerHTML = contenido;
                lista.appendChild(item);
            }
        }

        // Colocar enemigos en la loseta
        function colocarEnemigosEnLoseta(enemigos) {
            // Primero, ordenar enemigos por tamaño (más grandes primero)
            enemigos.sort((a, b) => {
                const tamanoA = obtenerDimensionesEnemigo(a.tamano).casillas;
                const tamanoB = obtenerDimensionesEnemigo(b.tamano).casillas;
                return tamanoB - tamanoA;
            });
            
            // Encontrar todas las casillas válidas y disponibles
            const casillasValidas = [];
            const casillas = document.querySelectorAll('.casilla:not(.invalida):not(.ocupada)');
            
            casillas.forEach(casilla => {
                casillasValidas.push({
                    elemento: casilla,
                    fila: parseInt(casilla.dataset.fila),
                    columna: parseInt(casilla.dataset.columna)
                });
            });
            
            // Mezclar casillas válidas para colocación aleatoria
            for (let i = casillasValidas.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [casillasValidas[i], casillasValidas[j]] = [casillasValidas[j], casillasValidas[i]];
            }
            
            // Intentar colocar cada enemigo
            const enemigosNoColocados = [];
            
            for (const enemigo of enemigos) {
                let colocado = false;
                
                for (const casilla of casillasValidas) {
                    if (!casilla.elemento.classList.contains('ocupada') && 
                        areaDisponible(casilla.fila, casilla.columna, enemigo.tamano)) {
                        
                        // Colocar el enemigo
                        colocarEnemigo(casilla.fila, casilla.columna, enemigo);
                        marcarAreaOcupada(casilla.fila, casilla.columna, enemigo.tamano);
                        colocado = true;
                        break;
                    }
                }
                
                if (!colocado) {
                    enemigosNoColocados.push(enemigo);
                }
            }
            
            // Mostrar advertencia si no se pudieron colocar todos los enemigos
            if (enemigosNoColocados.length > 0) {
                console.warn('No se pudieron colocar todos los enemigos:', enemigosNoColocados);
                
                // Agrupar enemigos no colocados para el mensaje
                const noColocadosAgrupados = {};
                enemigosNoColocados.forEach(e => {
                    noColocadosAgrupados[e.nombre] = (noColocadosAgrupados[e.nombre] || 0) + 1;
                });
                
                const mensaje = Object.entries(noColocadosAgrupados)
                    .map(([nombre, cantidad]) => `${cantidad}x ${nombre}`)
                    .join(', ');
                
                alert(`No hay suficiente espacio para colocar: ${mensaje}`);
            }
        }

        // Colocar un enemigo específico en la posición dada
        function colocarEnemigo(fila, columna, enemigo) {
            const matrizContainer = document.getElementById('matriz-loseta');
            const dimensiones = obtenerDimensionesEnemigo(enemigo.tamano);
            
            // Crear elemento enemigo
            const enemigoElement = document.createElement('div');
            enemigoElement.className = `enemigo ${enemigo.tamano.toLowerCase()}`;
            
            // Obtener la imagen del token
            const imagenToken = obtenerImagenToken(enemigo.nombre);
            
            // Establecer estilos según el tamaño
            enemigoElement.style.width = `calc(${dimensiones.ancho} * (100% / ${losetaSeleccionada.matriz[0].length}) - 4px)`;
            enemigoElement.style.height = `calc(${dimensiones.alto} * (100% / ${losetaSeleccionada.matriz.length}) - 4px)`;
            enemigoElement.style.left = `calc(${columna} * (100% / ${losetaSeleccionada.matriz[0].length}))`;
            enemigoElement.style.top = `calc(${fila} * (100% / ${losetaSeleccionada.matriz.length}))`;
            enemigoElement.style.position = 'absolute';
            enemigoElement.style.backgroundImage = `url(${imagenToken})`;
            enemigoElement.style.backgroundSize = 'contain';
            enemigoElement.style.backgroundPosition = 'center';
            enemigoElement.style.backgroundRepeat = 'no-repeat';
            enemigoElement.title = enemigo.nombre;
            
            // Añadir tooltip con información
            enemigoElement.dataset.tooltip = `${enemigo.nombre} (${enemigo.tamano})`;
            
            // Añadir evento para mostrar información al pasar el mouse
            enemigoElement.addEventListener('mouseenter', () => {
                // Podrías añadir un tooltip o información adicional aquí
                console.log(enemigoElement.dataset.tooltip);
            });
            
            matrizContainer.appendChild(enemigoElement);
        }
    </script>
</body>
</html>